Object subclass: #MainEntry	instanceVariableNames: 'pi ei'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormat'!!MainEntry commentStamp: 'zeroCrowsky 2/11/2016 23:39' prior: 0!MainEntry class is     Instance Variables	ei:		<Object>	pi:		<Object>!!MainEntry methodsFor: 'accessing' stamp: 'zeroCrowsky 2/12/2016 00:06'!pi	"comment stating purpose of message"	^pi! !!MainEntry methodsFor: 'accessing' stamp: 'zeroCrowsky 2/12/2016 00:07'!ei: anEi	"comment stating purpose of message"	ei := anEi! !!MainEntry methodsFor: 'accessing' stamp: 'zeroCrowsky 2/12/2016 00:08'!pi: anPi	"comment stating purpose of message"	pi := anPi! !!MainEntry methodsFor: 'accessing' stamp: 'zeroCrowsky 2/12/2016 00:07'!ei	"comment stating purpose of message"	^ei! !!MainEntry methodsFor: 'initialize' stamp: 'NicolasBerveglieri 2/12/2016 15:09'!initialize: anPi at: anEi	super initialize.	self pi: anPi.	self ei: anEi.	"comment stating purpose of message"! !!MainEntry methodsFor: 'initialize' stamp: 'NicolasBerveglieri 2/12/2016 15:09'!initialize: anPi	super initialize.	self initialize: anPi at: 0	"comment stating purpose of message"! !!MainEntry methodsFor: 'initialize' stamp: 'NicolasBerveglieri 2/12/2016 15:08'!initialize	super initialize.	"comment stating purpose of message"	ei := 0.	pi := 0! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!MainEntry class	instanceVariableNames: ''!!MainEntry class methodsFor: 'factory' stamp: 'NicolasBerveglieri 2/26/2016 15:40'!createMainEntry: id	"comment stating purpose of message"	^ self new initialize: id at: 0.! !TestCase subclass: #CDBTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormat'!!CDBTest methodsFor: 'as yet unclassified' stamp: 'NicolasBerveglieri 2/12/2016 15:00'!testSubtable	"comment stating purpose of message"	|cdb|	cdb := CDB new.	self assert: (cdb pointing:10) = (cdb subTable at:10)	! !!CDBTest methodsFor: 'as yet unclassified' stamp: 'NicolasBerveglieri 2/12/2016 15:22'!testSetNumberOfEntries|cdb|cdb := CDB new.self assert: (cdb mainTable at:11) ei = 0.cdb setNumberOfEntries: 5 at: 10.self assert: (cdb mainTable at:11 ) ei = 5 ! !!CDBTest methodsFor: 'as yet unclassified' stamp: 'NicolasBerveglieri 2/12/2016 16:07'!testAddSubtable |cdb|cdb := CDB new.cdb addSubtable: 10 and: 100.self assert: ((cdb pointing:10) size = 100).self assert: ((cdb mainTable at:10) ei = 100)! !!CDBTest methodsFor: 'as yet unclassified' stamp: 'NicolasBerveglieri 2/26/2016 16:09'!testResearchSucess |a subt | a := CDB new. a addSubtable: 1 and:100. subt := a subTable at:1. 2 to: 99 do: [ :x | subt at: x put: (0 -> 0) ]. subt at: 100 put: (513 -> 0).  self assert: (513 -> 0) = (a research: 513). ! !!CDBTest methodsFor: 'as yet unclassified' stamp: 'NicolasBerveglieri 2/26/2016 16:10'!testResearchFailure |a subt| a := CDB new. a addSubtable: 1 and:100. subt := a subTable at:1. 2 to: 100 do: [ :x | subt at: x put: (0 -> 0) ]. self assert: nil= (a research: 513).! !!CDBTest methodsFor: 'as yet unclassified' stamp: 'zeroCrowsky 2/12/2016 14:22'!testInitialize	"comment stating purpose of message"	|cdb|	cdb := CDB new.	self assert: 256 = cdb mainTable size	! !!CDBTest methodsFor: 'as yet unclassified' stamp: 'NicolasBerveglieri 2/26/2016 16:07'!testResearch |a subt| a := CDB new. a addSubtable: 1 and:100. subt := a subTable at:1. 2 to: 99 do: [ :x | subt at: x put: (0 -> 0) ]. subt at: 100 put: (513 -> 0).  self assert: (513 -> 0) = (a research: 513).! !!CDBTest methodsFor: 'as yet unclassified' stamp: 'NicolasBerveglieri 2/12/2016 16:11'!testHashOne|cdb|cdb := CDB new.self assert:(cdb hashOne:513) = 1! !Object subclass: #CDB	instanceVariableNames: 'mainTable subTable'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormat'!!CDB commentStamp: 'NicolasBerveglieri 2/26/2016 16:31' prior: 0!CDB is the main class of the CDBFormat package project. from her you can search keys and values in the database.!!CDB methodsFor: 'action' stamp: 'NicolasBerveglieri 2/26/2016 16:30'!research: h "search the key h in the Database. if the key is not found, return nil. if the key is found, return the element located there in the subtable"	| h2 mainentry myei id lsubt find break mreturn |	h2 := self hashOne: h.	mainentry := self mainTable at: h2.	myei := mainentry ei.	id:= (h bitShift: 8) % myei.	lsubt := self pointing: h2.	find := false.	break := false.	[((find not & break not) & (id <= myei))] whileTrue: [  		(lsubt at: id) isNil 			ifFalse: [((lsubt at: id) key = h) 							ifTrue: [ find := true ] 							ifFalse: [ id := id + 1 ]] 			ifTrue: [ break := true ]			]. 	find 		ifTrue: [ mreturn:= lsubt at: id ] 		ifFalse: [ mreturn:= nil ]. 	^ mreturn  "id to: myei do: [ :x | (lsubt at:id) ifNil:  ]"! !!CDB methodsFor: 'model creation' stamp: 'NicolasBerveglieri 2/26/2016 16:27'!addSubtable: aPi and: anEi"add an empty array (size = anEi) at the index (aPi) of the CDB subtable"self subTable at:aPi put:(Array new:anEi).(self mainTable at:aPi) ei:anEi! !!CDB methodsFor: 'initalize' stamp: 'NicolasBerveglieri 2/26/2016 16:27'!initialize "initialize the CDB database with its mainTable and its subTable"	super initialize.	mainTable := Array new: 256.	1 to: 256 do: [ :x | mainTable at: x put: (MainEntry new initialize: x - 1) ].	subTable := Array new: 256! !!CDB methodsFor: 'model protocol' stamp: 'NicolasBerveglieri 2/26/2016 16:27'!hashOne: h  "hachage function to go from the maintable to the subtable" ^(h % 256)! !!CDB methodsFor: 'accessing' stamp: 'NicolasBerveglieri 2/26/2016 16:28'!mainTable "return the maintable"	^ mainTable! !!CDB methodsFor: 'accessing' stamp: 'NicolasBerveglieri 2/26/2016 16:30'!setNumberOfEntries: nbr at:aPi "set the number of entry in an element of the mainTable"(mainTable at: aPi+1) ei: nbr! !!CDB methodsFor: 'accessing' stamp: 'NicolasBerveglieri 2/12/2016 14:50'!subTable	^ subTable! !!CDB methodsFor: 'accessing' stamp: 'NicolasBerveglieri 2/26/2016 16:28'!pointing: index "return the element at the index of the subTable" ^subTable at:index! !