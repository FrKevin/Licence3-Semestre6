Object subclass: #CdbEnumeration	instanceVariableNames: 'in eod pos'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormat'!!CdbEnumeration commentStamp: 'Kevingamelin 3/19/2016 12:44' prior: 0!An Enumeration containing a CdbElement for each entry in the constant database.	parameter:  filepath The CDB file to read.	Return:  An Enumeration containing a CdbElement for each entry in the constant database.!!CdbEnumeration methodsFor: 'modal control' stamp: 'kevingamelin 3/25/2016 13:03'!readLeInt	"Reads a little-endian integer from: in"	|A B C D|	A :=  in next bitAnd: 16rFF.	B := (in next bitAnd: 16rFF) << 8.	C := (in next bitAnd: 16rFF) << 16.	D := (in next bitAnd: 16rFF) << 24.		^ A bitOr: (B bitOr: (C bitOr: D)) ! !!CdbEnumeration methodsFor: 'modal control' stamp: 'Kevingamelin 3/19/2016 12:47'!finalize	" Finalizer"	in close.! !!CdbEnumeration methodsFor: 'modal control' stamp: 'kevingamelin 3/25/2016 13:30'!nextElement	"Returns the next data element in the CDB file"		| klen dlen key off count data |		"Read the key and value lengths"	klen := self readLeInt. 	pos := pos + 4.	dlen := self readLeInt.	pos := pos + 4.	"Read the key"	key := ByteArray new: klen.	off := 1.	[ off <= klen ] whileTrue: [ 		count := in readInto: key startingAt: off count: (klen-off + 1).		off := off + count.	].	pos := pos + klen.		"Read the data"		data  := ByteArray new: dlen.	off := 1.	[ off <= dlen ] whileTrue: [ 		count := in readInto: data startingAt: off count: (dlen-off + 1).		off := off + count.	].	pos := pos + dlen.		^ CdbElement new: key and: data.! !!CdbEnumeration methodsFor: 'modal control' stamp: 'Kevingamelin 3/19/2016 12:47'!hasMoreElements	"Returns true,if there are more elements in the constant database, false otherwise."	^ pos < eod.! !!CdbEnumeration methodsFor: 'accessing' stamp: 'Kevingamelin 3/19/2016 12:44'!in	"comment stating purpose of message"	^ in! !!CdbEnumeration methodsFor: 'as yet unclassified' stamp: 'Kevingamelin 3/19/2016 12:48'!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'self' -> self } ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!CdbEnumeration methodsFor: 'initalize' stamp: 'kevingamelin 3/22/2016 13:05'!initialize: filepath	|A B C D |	super initialize.	"comment stating purpose of message"		"Open the data file"	in := FileStream readOnlyFileNamed: filepath.	in binary.	"Read the end-of-data value"	A :=  (in next) bitAnd: 16rFF.	B := ((in next) bitAnd: 16rff) << 8.	C := ((in next) bitAnd: 16rff) << 16.	D := ((in next) bitAnd: 16rff) << 24.	eod := A bitOr: (B bitOr: (C bitOr: D)).		"Skip the rest of the hashtable"	in skip: 2048-4.		"Current data pointer"	pos := 2048	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CdbEnumeration class	instanceVariableNames: ''!!CdbEnumeration class methodsFor: 'new' stamp: 'Kevingamelin 3/19/2016 12:48'!new: aFilepath	 ^ self new		initialize: aFilepath;		yourself! !Object subclass: #Cdb	instanceVariableNames: 'file slotTable loop khash hslots hpos kpos'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormat'!!Cdb commentStamp: 'kevingamelin 2/26/2016 14:01' prior: 0!Cdb implements a Pharo interface!!Cdb methodsFor: 'modal control' stamp: 'Kevingamelin 2/27/2016 14:08'!close	"Closes the CDB database"		file close.	file := nil.! !!Cdb methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:02'!readUnsignedByteModulate	"Read an usnsigned byte" 	| h a b c d |		h := 0.	a := file next.	b := (file next) << 8.	c := (file next) << 16.	d:= (file next) << 24.		h := a bitOr: (b bitOr: (c bitOr: d)). 	^ h	! !!Cdb methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:43'!searchMatching: k and: key	"Search "	1 to: k size do: [ :i| 		((k at: i) = (key at: i)) 			ifFalse: [ 				^ false.			].	].	^ true! !!Cdb methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:42'!ifActionForLoopEqualZero: key	"comment stating purpose of message"		| u  slot|		(loop = 0) ifTrue: [ 			"Get the hash value for the key."			u := key cdbHash.			"Unpack the information for this record."			slot := u bitAnd: 255.						hslots := slotTable at: ((slot << 1) +2).			( hslots = 0) ifTrue: [ 				^ false.			].						hpos := slotTable at: ((slot << 1)+1).						"Store the hash value."			khash := u.						"Locate the slot containing this key."			u  := u >> 8.			u  := u % hslots.			u  := u << 3.			kpos := hpos + u.	].	^ true! !!Cdb methodsFor: 'modal control' stamp: 'kevingamelin 3/25/2016 13:14'!find: key	"Finds the first record stored under the given key"	| h pos klen dlen k d |		loop := 0.		"There are no keys if we could not read the slot table"	(slotTable == nil) ifTrue: [ ^ nil ].		"Locate the hash entry if we have not yet done so"		(self ifActionForLoopEqualZero: key) ifFalse: [		^ nil.	].	"Search all of the hash slots for this key"	[loop < hslots] whileTrue: [		file position: kpos.		h := self readUnsignedByteModulate. 		pos := self readUnsignedByteModulate.		(pos = 0) ifTrue: [ ^ nil ]. 				"Advance the loop count and key position"		loop := loop +1.		kpos := kpos +8.		(kpos = (hpos + (hslots << 3))) ifTrue: [ kpos := hpos ].				"Ignore this entry if the hash values do not match"		(h = khash ) ifTrue: [			"Get the length of the key and data in this hash slot entry."			file position: pos.						klen := self readUnsignedByteModulate.						(klen = key size) ifTrue: [ 				dlen := self readUnsignedByteModulate.								k := ByteArray new: klen.				file readInto: k startingAt: 1 count: klen.								(self searchMatching: k and: key) ifTrue: [ 					d := ByteArray new: dlen.					file readInto: d startingAt: 1 count: dlen.					^ d.				].			].		].	].  	^ nil.! !!Cdb methodsFor: 'initialize' stamp: 'kevingamelin 3/22/2016 13:07'!initialize: filepath	| table offset pos len  A B C D ia ib iecart| 	super initialize.	"Creates an instance of the Cdb class and loads the given CDB file."	"Open the CDB file"	file := FileStream readOnlyFileNamed: filepath.	file binary.		" Read and parse the slot table"	table := ByteArray new: 2048.	file readInto: table startingAt: 1 count: 2048. 		slotTable := IntegerArray new: (256*2).	offset := 1.	iecart := 0.	1 to: 256 do: [ :i|		A :=  (table at: offset) bitAnd: 16rff.		offset := offset+1.		B := ((table at: offset) bitAnd: 16rff) <<  8.		offset := offset +1.		C := ((table at: offset) bitAnd: 16rff) <<  16.		offset := offset+1.		D := ((table at: offset) bitAnd: 16rff) <<  24. 		offset := offset+1.		pos := A bitOr: (B bitOr: (C bitOr: D)). 						"Second stape"		A := (table at: offset) bitAnd: 16rff.		offset := offset+1.		B := ((table at: offset) bitAnd: 16rff) <<  8.		offset := offset +1.		C := ((table at: offset) bitAnd: 16rff) <<  16.		offset := offset+1.		D := ((table at: offset) bitAnd: 16rff) <<  24.		offset := offset+1.		len := A bitOr: (B bitOr: (C bitOr: D)).				"Third stape"		ia := i + iecart.		ib := ia +1.		iecart := iecart + 1.		slotTable at: ia put: pos.		slotTable at: ib put: len.		"Test static: entre java sysout et pharo Transcript"	].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cdb class	instanceVariableNames: ''!!Cdb class methodsFor: 'new' stamp: 'KevinGamelin 3/18/2016 14:56'!new: aString	 ^ self new		initialize: aString;		yourself! !!Cdb class methodsFor: 'enumerating' stamp: 'Kevingamelin 3/19/2016 15:03'!elements: filepath	"Returns an Enumeration containing a CdbElement for each entry in the constant database" ^ CdbEnumeration new: filepath.! !Object subclass: #CdbMake	instanceVariableNames: 'file hashPointers tableCount tableStart pos'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormat'!!CdbMake commentStamp: 'kevingamelin 2/26/2016 13:59' prior: 0!CdbMake implements the database-creation side of!!CdbMake methodsFor: 'modal control' stamp: 'Anonymous 3/19/2016 15:59'!posplus: count	"Advances the file pointer by count bytes, throwing an exception if doing so would cause the file to grow beyond 4 GB."	| newpos |	newpos := pos + count.	(newpos < count) 	ifTrue: [		FileStreamException new signal: 'CDB file is too big.'.	] ifFalse: [		pos:= newpos. 	]! !!CdbMake methodsFor: 'modal control' stamp: 'kevingamelin 3/25/2016 13:28'!writeLeInt: v	"Writes an integer in little-endian format to the constant database at the current file offset."		|a b c d|	a := v bitAnd: 16rff.	b := (v >> 8) bitAnd: 16rff.	c := (v >> 16) bitAnd: 16rff.	d := (v >> 24) bitAnd: 16rff.		file nextBytesPutAll: a asByteArray.	file nextBytesPutAll: b asByteArray.	file nextBytesPutAll: c asByteArray.	file nextBytesPutAll: d asByteArray.! !!CdbMake methodsFor: 'modal control' stamp: 'Anonymous 3/19/2016 20:08'!add: key and: data	"Adds a key to the constant database"	| hash itc|		"Write out the key length."	self writeLeInt: (key size).		"Write out the data length"	self writeLeInt: (data size).		"Write out the key"	file  nextBytesPutAll: key.		"Write out the data."	file  nextBytesPutAll: data.		"Add the hash pointer to our list"	hash := key cdbHash.	"Transcript show: 'add, elm : hash : '; show: hash; show: ' pos : '; show: pos; cr."	hashPointers add: (hash -> pos).		"Add this item to the count"	itc := (hash bitAnd: 16rff) + 1.	"Transcript show: 'add, itc : '; show: itc; cr."	tableCount at: itc put: ((tableCount at: itc) +1).		"Update the file position pointer"	self posplus: 8.	self posplus: (key size).	self posplus: (data size).! !!CdbMake methodsFor: 'modal control' stamp: 'kevingamelin 3/25/2016 13:52'!finish	"Finalizes the constant database."	| curEntry slotPointers slotTable |		"Find the start of each hash table"	curEntry := 0.	1 to: 256 do: [ :i| 		curEntry := curEntry + (tableCount at: i).		tableStart at: i put: curEntry.	].		"Create a new hash pointer list in order by hash table"	slotPointers := Array new: (hashPointers size).	hashPointers do: [ :elm | | its isp | 		its := ((elm key) bitAnd: 16rff) +1.		tableStart at: its put: (tableStart at: its) -1.		isp := (tableStart at: its) +1.		slotPointers at: isp put: elm.	].	"Write out each of the hash tables, building the slot table in the process."	slotTable := ByteArray new: 2048.	1 to: 256 do: [ :i | | len curSlotPointer hashTable im1|		"Get the length of the hashtable"		len := (tableCount at: i) *2.				"Store the position of this table in the slot table"		im1 := i - 1.		slotTable at: ((im1 * 8) + 1)		put: (pos 			bitAnd: 16rff).		slotTable at: ((im1 * 8) + 2)		put: ((pos >>  8) 	bitAnd: 16rff).		slotTable at: ((im1 * 8) + 3) 	   put: ((pos >> 16) 	bitAnd: 16rff).		slotTable at: ((im1 * 8) + 4) 		put: ((pos >> 24) 	bitAnd: 16rff).		slotTable at: ((im1 * 8) + 5 + 0) put: (len 			bitAnd: 16rff).		slotTable at: ((im1 * 8) + 5 + 1) put: ((len >>  8) 	bitAnd: 16rff).		slotTable at: ((im1 * 8) + 5 + 2) put: ((len >> 16) 	bitAnd: 16rff).		slotTable at: ((im1 * 8) + 5 + 3) put: ((len >> 24)	bitAnd: 16rff).				"Build the hash table"			curSlotPointer := tableStart at: i.		hashTable := Array new: len.		1 to: (tableCount at: i) do: [ :u | | hp where |			"Get the hash pointer"			hp := slotPointers at: (curSlotPointer +1).			curSlotPointer := curSlotPointer + 1.						"Locate a free space in the hash table"			where := ((hp key >> 8) % len) +1.			[(hashTable at: where) = nil ] 				whileFalse: [					where := where + 1.					(where == (len+1)) ifTrue: [ where := 1. ].				].						"Store the hash pointer"			hashTable at: where put: hp.		].			"Write out the hash table."		1 to: len do: [ :u | | hp |			hp := hashTable at: u.			( hp = nil )				ifFalse: [ 					self writeLeInt: ((hashTable at: u) key).					self writeLeInt: ((hashTable at: u) value).				] ifTrue: [ 					self writeLeInt: 0.					self writeLeInt: 0.				].			self posplus: 8.		].	].	"Seek back to the beginning of the file and write out the slot table."	file position: 0.	file nextPutAll: slotTable.		"Close the file"	file close.! !!CdbMake methodsFor: 'starting' stamp: 'Anonymous 3/19/2016 20:21'!start: filepath	"Begins the constant database creation process."	"Initialize the class."	hashPointers  := LinkedList new.	tableCount := IntegerArray new: 256.	tableStart := IntegerArray new: 256.		"Clear the table counts."	1 to: 256 do: [ :x | tableCount at: x put: 0].		"Open the file"	file  := FileStream forceNewFileNamed: filepath.		"Seek to the end of the header."	pos  := 2048.	file position: pos.! !!CdbMake methodsFor: 'initialize' stamp: 'Anonymous 3/18/2016 22:29'!initialize	super initialize	"constructs a CdbMake object and prepares it for the creation of a constant database."	! !Object subclass: #CdbElement	instanceVariableNames: 'data key'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormat'!!CdbElement commentStamp: 'kevingamelin 2/26/2016 13:54' prior: 0!CdbElement represents a single element in a constant database.!!CdbElement methodsFor: 'getter' stamp: 'kevingamelin 2/26/2016 14:06'!getData	"The data value for this element."	^ data! !!CdbElement methodsFor: 'getter' stamp: 'kevingamelin 2/26/2016 14:06'!getKey	"The key value for this element."	^ key! !!CdbElement methodsFor: 'initalize' stamp: 'Kevingamelin 3/18/2016 21:30'!initialize: 	k  and: d	"Creates an instance of the CdbElement class and initializes it with the given key and data values."	super initialize.		key := k.	data := d! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CdbElement class	instanceVariableNames: ''!!CdbElement class methodsFor: 'new' stamp: 'Kevingamelin 3/18/2016 21:29'!new: aKey and: aData	 ^ self new		initialize: aKey and: aData;		yourself! !Object subclass: #MyPlayground	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormat'!!MyPlayground commentStamp: 'kevingamelin 3/22/2016 13:23' prior: 0!Demo.!!MyPlayground methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/19/2016 16:23'!myPlaygroundTestFileNext	"comment stating purpose of message"	| fileW fileR |	fileW := FileStream forceNewFileNamed: 'E:\Dev\GitRepositery\Licence3-Semestre6\OpenDevs\Ressources\example\next.test'.	fileW binary.	fileW next: 15.	fileW close.		fileR := FileStream fileNamed: 'E:\Dev\GitRepositery\Licence3-Semestre6\OpenDevs\Ressources\example\next.test'.		fileR binary.	fileR next.	fileR close.	! !!MyPlayground methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/19/2016 15:38'!myPlaygroundCdbMake	"Playground example for use CDB make"	| maker |	maker := CdbMake new.	maker start: 'E:\Dev\GitRepositery\Licence3-Semestre6\OpenDevs\Ressources\example\makerpharo.cdb'.	maker add: ('three' asByteArray) and: ('Golden State Warriors' asByteArray).	maker add: ('four' asByteArray) and: ('Record of Chicago Bulls' asByteArray). 	maker finish.! !!MyPlayground methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/19/2016 17:21'!myPlaygroundCdbLinkendList	"comment stating purpose of message"	| list |	list := LinkedList new.	list add: 10 -> 20.	list add: 30 -> 40.	list.	list do: [ :elm |		Transcript show: elm; cr.	].	(10 -> 20) key.	(10 -> 20) value.! !!MyPlayground methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/18/2016 22:15'!myPlaygroundCdbFind	"comment stating purpose of message"	|cdb key r|	cdb := Cdb new: 'E:\Dev\GitRepositery\Licence3-Semestre6\OpenDevs\Ressources\example\basefile.cdb'.	key := 'one' asByteArray.	r := cdb find: key.	cdb close.	r asString ! !!MyPlayground methodsFor: 'as yet unclassified' stamp: 'Kevingamelin 3/19/2016 15:08'!myPlaygroundCdbEnum	"comment stating purpose of message"	| em cdbElt | 	em := Cdb elements: 'E:\Dev\GitRepositery\Licence3-Semestre6\OpenDevs\Ressources\example\basefile.cdb'.	[ em hasMoreElements ] whileTrue: [ 		cdbElt := em nextElement.		Transcript show: 'Loop elements : Value : '; show: (cdbElt getData) asString; show: ' Key : '; show: (cdbElt getKey) asString; cr.   ].! !