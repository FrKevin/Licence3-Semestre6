Object subclass: #Cdb	instanceVariableNames: 'file slotTable loop khash hslots hpos kpos'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!Cdb commentStamp: 'kevingamelin 2/26/2016 14:01' prior: 0!Cdb implements a Pharo interface!!Cdb methodsFor: 'initialize' stamp: 'KevinGamelin 3/18/2016 15:59'!initialize: filepath	| table offset pos len  A B C D ia ib iecart| 	super initialize.	"Creates an instance of the Cdb class and loads the given CDB file."	"Open the CDB file"	file := FileStream fileNamed: filepath.	file binary.		" Read and parse the slot table"	table := ByteArray new: 2048.	file readInto: table startingAt: 1 count: 2048. 		slotTable := IntegerArray new: (256*2).	offset := 1.	iecart := 0.	1 to: 256 do: [ :i|		A :=  (table at: offset) bitAnd: 16rff.		offset := offset+1.		B := ((table at: offset) bitAnd: 16rff) <<  8.		offset := offset +1.		C := ((table at: offset) bitAnd: 16rff) <<  16.		offset := offset+1.		D := ((table at: offset) bitAnd: 16rff) <<  24. 		offset := offset+1.		pos := A bitOr: (B bitOr: (C bitOr: D)). 						"Second stape"		A := (table at: offset) bitAnd: 16rff.		offset := offset+1.		B := ((table at: offset) bitAnd: 16rff) <<  8.		offset := offset +1.		C := ((table at: offset) bitAnd: 16rff) <<  16.		offset := offset+1.		D := ((table at: offset) bitAnd: 16rff) <<  24.		offset := offset+1.		len := A bitOr: (B bitOr: (C bitOr: D)).				"Third stape"		ia := i + iecart.		ib := ia +1.		iecart := iecart + 1.		slotTable at: ia put: pos.		slotTable at: ib put: len.		"Test static: entre java sysout et pharo Transcript"	].! !!Cdb methodsFor: 'modal control' stamp: 'Kevingamelin 2/27/2016 14:08'!close	"Closes the CDB database"		file close.	file := nil.! !!Cdb methodsFor: 'modal control' stamp: 'KevinGamelin 3/4/2016 16:20'!elements: filepath	"Returns an Enumeration containing a CdbElement for each entry in the constant database"	^ Enumeration new: filepath.! !!Cdb methodsFor: 'modal control' stamp: 'KevinGamelin 3/18/2016 17:07'!searchMatching: k and: key	"Search "	Transcript show: 'k size : '; show: (k size); show: '    key size : '; show: (key size); cr. 	1 to: k size do: [ :i| 		((k at: i) = (key at: i)) 			ifFalse: [ 				^ false.			].	].	^ true! !!Cdb methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:03'!ifActionForLoopEqualZero: key	"comment stating purpose of message"		| u  slot|		"core := Core new."		(loop = 0) ifTrue: [ 			 "Get the hash value for the key."			"u := core hash: key."			u := key cdbHash.			"Unpack the information for this record."			slot := u bitAnd: 255.						hslots := slotTable at: ((slot << 1) +2).			( hslots = 0) ifTrue: [ 				^ false.			].						hpos := slotTable at: ((slot << 1)+1).						"Store the hash value."			khash := u.						"Locate the slot containing this key."			u  := u >> 8.			u  := u % hslots.			u  := u << 3.			Transcript show: 'u= '; show: u; show: ' et hpos '; show: hpos; cr. 			kpos := hpos + u.	].	^ true! !!Cdb methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:02'!find: key	"Finds the first record stored under the given key"	| h pos klen dlen k d |		loop := 0.		"There are no keys if we could not read the slot table"	(slotTable == nil) ifTrue: [ ^ nil ].		"Locate the hash entry if we have not yet done so"		(self ifActionForLoopEqualZero: key) ifFalse: [		^ nil.	].	"Search all of the hash slots for this key"	[loop < hslots] whileTrue: [		file position: kpos.		h := self readUnsignedByteModulate. 		pos := self readUnsignedByteModulate.		(pos = 0) ifTrue: [ ^ nil ]. 				"Advance the loop count and key position"		loop := loop +1.		kpos := kpos +8.		(kpos = (hpos + (hslots << 3))) ifTrue: [ kpos := hpos ].				"Ignore this entry if the hash values do not match"		(h = khash ) ifTrue: [			"Get the length of the key and data in this hash slot entry."			file position: pos.						klen := self readUnsignedByteModulate.						(klen = key size) ifTrue: [ 				dlen := self readUnsignedByteModulate.								k := ByteArray new: klen.				file readInto: k startingAt: 1 count: klen.								(self searchMatching: k and: key) ifTrue: [ 					d := ByteArray new: dlen.					file readInto: d startingAt: 1 count: dlen.					^ d.				].			].		].	].  	^ nil.! !!Cdb methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:02'!readUnsignedByteModulate	"Read an usnsigned byte" 	| h a b c d |		h := 0.	a := file next.	b := (file next) << 8.	c := (file next) << 16.	d:= (file next) << 24.		h := a bitOr: (b bitOr: (c bitOr: d)). 	^ h	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Cdb class	instanceVariableNames: ''!!Cdb class methodsFor: 'new' stamp: 'KevinGamelin 3/18/2016 14:56'!new: aString	 ^ self new		initialize: aString;		yourself! !Object subclass: #CdbElement	instanceVariableNames: 'data key'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!CdbElement commentStamp: 'kevingamelin 2/26/2016 13:54' prior: 0!CdbElement represents a single element in a constant database.!!CdbElement methodsFor: 'initalize' stamp: 'KevinGamelin 3/4/2016 13:56'!configure:  k  and: d	super initialize.	"Creates an instance of the CdbElement class and initializes it with the given key and data values."	key := k.	data := d! !!CdbElement methodsFor: 'initalize' stamp: 'Kevingamelin 3/18/2016 21:30'!initialize: 	k  and: d	"Creates an instance of the CdbElement class and initializes it with the given key and data values."	super initialize.		key := k.	data := d! !!CdbElement methodsFor: 'getter' stamp: 'kevingamelin 2/26/2016 14:06'!getData	"The data value for this element."	^ data! !!CdbElement methodsFor: 'getter' stamp: 'kevingamelin 2/26/2016 14:06'!getKey	"The key value for this element."	^ key! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CdbElement class	instanceVariableNames: ''!!CdbElement class methodsFor: 'new' stamp: 'Kevingamelin 3/18/2016 21:29'!new: aKey and: aData	 ^ self new		initialize: aKey and: aData;		yourself! !Object subclass: #Enumeration	instanceVariableNames: 'in eod pos'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!Enumeration commentStamp: 'KevinGamelin 3/4/2016 16:18' prior: 0!An Enumeration containing a CdbElement for each entry in the constant database.	parameter:  filepath The CDB file to read.	Return:  An Enumeration containing a CdbElement for each entry in the constant database.!!Enumeration methodsFor: 'modal control' stamp: 'KevinGamelin 3/7/2016 10:51'!readLeInt	"Reads a little-endian integer from: in"	|A B C D|	A :=  in next bitAnd: 16rFF.	B := (in next bitAnd: 16rFF) << 8.	C := (in next bitAnd: 16rFF) << 16.	D := (in next bitAnd: 16rFF) << 24.	^ A bitOr: (B bitOr: (C bitOr: D)) ! !!Enumeration methodsFor: 'modal control' stamp: 'KevinGamelin 3/4/2016 14:08'!finalize	" Finalizer"	in close.	! !!Enumeration methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:09'!hasMoreElements	"Returns true,if there are more elements in the constant database, false otherwise."	^ pos < eod.! !!Enumeration methodsFor: 'modal control' stamp: 'Kevingamelin 3/18/2016 21:35'!nextElement	"Returns the next data element in the CDB file"		| klen dlen key off count data |		"Read the key and value lengths"	klen := self readLeInt. 	pos := pos + 4.	dlen := self readLeInt.	pos := pos + 4.		"Read the key"	key := ByteArray new: klen.	off := 1.	[ off < klen ] whileTrue: [ 		count := in readInto:  key startingAt: off  count: (klen-off).		off := off + count.	].	pos := pos + klen.		"Read the data"	data  := ByteArray new: dlen.	off := 1.	[ off < dlen ] whileTrue: [ 		count := in readInto:  data startingAt: off  count: (dlen-off).		off := off + count.	].	pos := pos + dlen.		"Return a CdbElement with the key and data"	^ CdbElement new: key and: data.! !!Enumeration methodsFor: 'initalize' stamp: 'KevinGamelin 3/7/2016 10:45'!initialize: filepath	|A B C D |	super initialize.	"comment stating purpose of message"		"Open the data file"	in := FileStream forceNewFileNamed: filepath.	in binary.		"Read the end-of-data value"	A :=  in next bitAnd: 16rFF.	B := (in next bitAnd: 16rff) << 8.	C := (in next bitAnd: 16rff) << 16.	D := (in next bitAnd: 16rff) << 24.	eod := A bitOr: (B bitOr: (C bitOr: D)).		"Skip the rest of the hashtable"	in position: 2048-4.		"Current data pointer"	pos := 2048		! !!Enumeration methodsFor: 'as yet unclassified' stamp: 'KevinGamelin 3/11/2016 17:47'!gtInspectorDetailsIn: composite	<gtInspectorPresentationOrder: 30>	^ composite table		title: [ 'Details' ];		display: [ 					{'self' -> self } ];		column: 'Key' evaluated: #key;		column: 'Value' evaluated: #value;		send: #value! !!Enumeration methodsFor: 'accesing' stamp: 'Anonymous 2/29/2016 11:01'!in	"comment stating purpose of message"	^ in! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Enumeration class	instanceVariableNames: ''!!Enumeration class methodsFor: 'new' stamp: 'Kevingamelin 3/18/2016 21:36'!new: aString	 ^ self new		initialize: aString;		yourself! !Object subclass: #MyPlayground	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!MyPlayground commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!MyPlayground methodsFor: 'as yet unclassified' stamp: 'Anonymous 3/18/2016 22:15'!myPlaygroundCdbFind	"comment stating purpose of message"	|cdb key r|	cdb := Cdb new: 'E:\Dev\GitRepositery\Licence3-Semestre6\OpenDevs\Ressources\example\basefile.cdb'.	key := 'one' asByteArray.	r := cdb find: key.	cdb close.	r asString ! !Object subclass: #CdbHashPointer	instanceVariableNames: 'hash pos'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!CdbHashPointer commentStamp: 'Kevingamelin 2/26/2016 21:34' prior: 0!The hash value of this entry. !!CdbHashPointer methodsFor: 'initialize' stamp: 'Kevingamelin 3/18/2016 21:32'!initialize: h and: p	"Creates a new CdbHashPointer and initializes it with the given hash value and position."	super initialize.		self hash = h.	self pos = p.	! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CdbHashPointer class	instanceVariableNames: ''!!CdbHashPointer class methodsFor: 'new' stamp: 'Kevingamelin 3/18/2016 21:32'!new: aHash and: aPos	 ^ self new		initialize: aHash and: aPos;		yourself! !Object subclass: #CdbMake	instanceVariableNames: 'file hashPointers tableCount tableStart pos core'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!CdbMake commentStamp: 'kevingamelin 2/26/2016 13:59' prior: 0!CdbMake implements the database-creation side of!!CdbMake methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:06'!finish	"Finalizes the constant database."	| curEntry slotPointers hp slotTable len curSlotPointer hashTable where|		"Find the start of each hash table"	curEntry := 0.	1 to: 256 do: [ :i| 		curEntry := curEntry + tableCount at: i.		tableStart at: i put: curEntry.	].	"Create a new hash pointer list in order by hash table"	slotPointers := Array new: hashPointers size.	hashPointers do: [ :i |  		hp := (CdbHashPointer) i.		slotPointers at: ( (tableStart at: hp hash bitAnd: 16rff ) -1) put: hp.	].	"Write out each of the hash tables, building the slot table in the process."	slotTable := ByteArray new: 2048.	1 to: 256 do: [ :i |		"Get the length of the hashtable"		len := (tableCount at: i) *2.				"Store the position of this table in the slot table"		slotTable at: (i * 8) + 0 		put: (pos 			bitAnd: 16rff).		slotTable at: (i * 8) + 1 		put: ((pos >>  8) 	bitAnd: 16rff).		slotTable at: (i * 8) + 2 		put: ((pos >> 16) 	bitAnd: 16rff).		slotTable at: (i * 8) + 3 		put: ((pos >> 24) 	bitAnd: 16rff).		slotTable at: (i * 8) + 4 + 0 	put: (len 			bitAnd: 16rff).		slotTable at: (i * 8) + 4 + 1 	put: ((len >>  8) 	bitAnd: 16rff).		slotTable at: (i * 8) + 4 + 2 	put: ((len >> 16) 	bitAnd: 16rff).		slotTable at: (i * 8) + 4 + 3 	put: ((len >>> 24)	bitAnd: 16rff).				"Build the hash table"			curSlotPointer := tableStart at: i.		hashTable := Array new: len.		1 to: 256 do: [ :j |			"Get the hash pointer"			hp := slotPointers at: curSlotPointer+1.						"Locate a free space in the hash table"			where := (hp hash >> 8) % len.			[hashTable at: where ~= nil ] 				whileTrue: [					(where+1 == len) ifTrue: [ where := 0 ].				]						"Store the hash pointer"			hashTable at: where put: hp.		].		1 to: len do: [ :j | 			hp := hashTable at: j.			( hp ~= nil )				ifTrue: [ 					self writeLeInt: (hashTable at: j hash).					self writeLeInt: (hashTable at: j pos).				]; ifFalse: [ 					self writeLeInt: 0.					self writeLeInt: 0.				].			self posplus: 8.		].	].	"Seek back to the beginning of the file and write out the slot table."	file position: 0.	file nextPutAll: slotTable.		"Close the file"	file close.	! !!CdbMake methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:06'!add: key and: data	"Adds a key to the constant database"	| hash |		"Write out the key length."	self writeLeInt: key size.	"Write out the data length"	self writeLeInt: data size.	"Write out the key"	file  nextBytesPutAll: key.	"Write out the data."	file  nextBytesPutAll: data.		"Add the hash pointer to our list"	hash := key cdbHash.	hashPointers add: CdbHashPointer new: hash and: self pos.		"Add this item to the count"	tableCount at: hash bitAnd: 16rff put: (tableCount at: hash bitAnd: 16rff) +1.		"Update the file position pointer"	self posplus: 8.	self posplus: key size.	self posplus: data size.! !!CdbMake methodsFor: 'modal control' stamp: 'Anonymous 3/18/2016 22:08'!posplus: count	"Advances the file pointer by count bytes, throwing an exception if doing so would cause the file to grow beyond 4 GB."	| newpos |	newpos := self pos + count.	(newpos < count) ifTrue: [		FileStreamException new signal: 'CDB file is too big.'.	]; ifFalse: [		pos:= newpos. 	]! !!CdbMake methodsFor: 'modal control' stamp: 'kevingamelin 2/26/2016 16:34'!writeLeInt: v	"Writes an integer in little-endian format to the constant database at the current file offset."	file nextBytesPutAll: v bitAnd: 16rff.	file nextBytesPutAll: (v >>  8) bitAnd: 16rff.	file nextBytesPutAll: (v >>  16) bitAnd: 16rff.	file nextBytesPutAll: (v >>  24) bitAnd: 16rff.! !!CdbMake methodsFor: 'initialize' stamp: 'Kevingamelin 2/26/2016 22:29'!initialize	super initialize	"constructs a CdbMake object and prepares it for the creation of a constant database."		self core Core new.! !!CdbMake methodsFor: 'starting' stamp: 'KevinGamelin 3/4/2016 14:56'!start: filepath	"Begins the constant database creation process."	hashPointers  = LinkedList new.	tableCount = Array new: 256.	tableStart = Array new: 256.	1 to: 256 do: [ :x | tableCount at: x put: 0].	file  := FileStream fileNamed: filepath .	pos  := 2048.	file position: pos.	! !'From Pharo4.0 of 18 March 2013 [Latest update: #40626] on 18 March 2016 at 10:16:04.737665 pm'!!ByteArray methodsFor: '*CDBFormatJavaLike' stamp: 'Anonymous 3/18/2016 22:04'!cdbHash	"Computes and returns the hash value for the given key."	| h l k |	h := 5381.	1 to: self size do: [ :i | 			l := h << 5.			h := h + ( l bitAnd: 16r00000000ffffffff).			h := h bitAnd: 16r00000000ffffffff.						k := self at: i.			k := (k + 16r100) bitAnd: 16rff.						h := h bitXor: k.	].	^ h bitAnd: 16r00000000ffffffff.! !