Object subclass: #CdbMake	instanceVariableNames: 'file hashPointers tableCount tableStart pos core'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!CdbMake commentStamp: 'kevingamelin 2/26/2016 13:59' prior: 0!CdbMake implements the database-creation side of!!CdbMake methodsFor: 'initialize' stamp: 'Kevingamelin 2/26/2016 22:29'!initialize	super initialize	"constructs a CdbMake object and prepares it for the creation of a constant database."		self core Core new.! !!CdbMake methodsFor: 'starting' stamp: 'kevingamelin 2/26/2016 15:07'!start: filepath	"Begins the constant database creation process."	hashPointers  = LinkedList new.	tableCount = Array new: 256.	tableStart = Array new: 256.	1 to: 256 do: [ :x | tableCount at: x put: 0].	file  := FileStream forceNewFileNamed: filepath .	pos  := 2048.	file position: pos.	! !!CdbMake methodsFor: 'modal control' stamp: 'Kevingamelin 2/27/2016 15:04'!add: key and: data	"Adds a key to the constant database"	| hash |		"Write out the key length."	self writeLeInt: key size.	"Write out the data length"	self writeLeInt: data size.	"Write out the key"	file  nextBytesPutAll: key.	"Write out the data."	file  nextBytesPutAll: data.		"Add the hash pointer to our list"	hash := core hash: key.	hashPointers add: CdbHashPointer new: hash and: self pos.		"Add this item to the count"	tableCount at: hash bitAnd: 16rff put: (tableCount at: hash bitAnd: 16rff) +1.		"Update the file position pointer"	self posplus: 8.	self posplus: key size.	self posplus: data size.! !!CdbMake methodsFor: 'modal control' stamp: 'Kevingamelin 2/26/2016 22:00'!posplus: count	"Advances the file pointer by count bytes, throwing an exception if doing so would cause the file to grow beyond 4 GB."	| newpos |	newpos := self pos + count.	(newpos < count) ifTrue: [		FileStreamException new signal: 	'CDB file is too big.'.	]; ifFalse: [		pos:= newpos. 	]! !!CdbMake methodsFor: 'modal control' stamp: 'kevingamelin 2/26/2016 16:34'!writeLeInt: v	"Writes an integer in little-endian format to the constant database at the current file offset."	file nextBytesPutAll: v bitAnd: 16rff.	file nextBytesPutAll: (v >>  8) bitAnd: 16rff.	file nextBytesPutAll: (v >>  16) bitAnd: 16rff.	file nextBytesPutAll: (v >>  24) bitAnd: 16rff.! !!CdbMake methodsFor: 'modal control' stamp: 'Kevingamelin 2/26/2016 23:31'!finish	"Finalizes the constant database."	| curEntry slotPointers hp slotTable len curSlotPointer hashTable where|		"Find the start of each hash table"	curEntry := 0.	1 to: 256 do: [ :i| 		curEntry := curEntry + tableCount at: i.		tableStart at: i put: curEntry.	].	"Create a new hash pointer list in order by hash table"	slotPointers := Array new: hashPointers size.	hashPointers do: [ :i | 		Transcript  show: i; cr. 		hp := (CdbHashPointer) i.		slotPointers at: ( (tableStart at: hp hash bitAnd: 16rff ) -1) put: hp.	].	"Write out each of the hash tables, building the slot table in the process."	slotTable := ByteArray new: 2048.	1 to: 256 do: [ :i |		"Get the length of the hashtable"		len := (tableCount at: i) *2.				"Store the position of this table in the slot table"		slotTable at: (i * 8) + 0 		put: (pos 			bitAnd:  16rff).		slotTable at: (i * 8) + 1 		put: ((pos >>  8) 	bitAnd: 16rff).		slotTable at: (i * 8) + 2 		put: ((pos >> 16) 	bitAnd: 16rff).		slotTable at: (i * 8) + 3 		put: ((pos >> 24) 	bitAnd: 16rff).		slotTable at: (i * 8) + 4 + 0 	put: (len 			bitAnd: 16rff).		slotTable at: (i * 8) + 4 + 1 	put: ((len >>  8) 	bitAnd: 16rff).		slotTable at: (i * 8) + 4 + 2 	put: ((len >> 16) 	bitAnd: 16rff).		slotTable at: (i * 8) + 4 + 3 	put: ((len >>> 24)	bitAnd: 16rff).				"Build the hash table"			curSlotPointer := tableStart at: i.		hashTable := Array new: len.		1 to: 256 do: [ :j |			"Get the hash pointer"			hp := slotPointers at: curSlotPointer+1.						"Locate a free space in the hash table"			where := (hp hash >> 8) % len.			[hashTable at: where ~= nil ] 				whileTrue: [					(where+1 == len) ifTrue: [ where := 0 ].				]						"Store the hash pointer"			hashTable at: where put: hp.		].		1 to: len do: [ :j | 			hp := hashTable at: j.			( hp ~= nil )				ifTrue: [ 					self writeLeInt: (hashTable at: j hash).					self writeLeInt: (hashTable at: j pos).				]; ifFalse: [ 					self writeLeInt: 0.					self writeLeInt: 0.				].			self posplus: 8.		].	].	"Seek back to the beginning of the file and write out the slot table."	file position: 0.	file nextPutAll: slotTable.		"Close the file"	file close.	! !Object subclass: #Enumeration	instanceVariableNames: 'in eod'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!Enumeration commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!Enumeration methodsFor: 'accesing' stamp: 'Anonymous 2/29/2016 11:01'!in	"comment stating purpose of message"	^ in! !!Enumeration methodsFor: 'modal control' stamp: 'Anonymous 2/29/2016 11:00'!finalizer	" Finalizer "	in close.	! !!Enumeration methodsFor: 'initalize' stamp: 'Anonymous 2/29/2016 11:15'!initialize: filepath	super initialize.	"comment stating purpose of message"	in := FileStream forceNewFileNamed: filepath.	in binary.	eod := (in nextBytes)	! !Object subclass: #Cdb	instanceVariableNames: 'file slotTable loop khash hslots hpos kpos'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!Cdb commentStamp: 'kevingamelin 2/26/2016 14:01' prior: 0!Cdb implements a Pharo interface!!Cdb methodsFor: 'modal control' stamp: 'Kevingamelin 2/27/2016 14:08'!close	"Closes the CDB database"		file close.	file := nil.! !!Cdb methodsFor: 'modal control' stamp: 'Kevingamelin 2/27/2016 15:28'!find: key	"Finds the first record stored under the given key"		self findstart: key.	^ self findnext: key.! !!Cdb methodsFor: 'modal control' stamp: 'Kevingamelin 2/27/2016 15:22'!findnext: key	"Finds the next record stored under the given key"	| u core slot h pos klen dlen match k d |		"There are no keys if we could not read the slot table"	(slotTable == nil) ifTrue: [ ^ nil ].		"Locate the hash entry if we have not yet done so"	(loop == 0 )ifTrue: [		core :=  Core new.				"Get the hash value for the key."		u := core hash: key.				"Unpack the information for this record"		slot := u bitAnd: 255.		hslots := slotTable at: (slot << 1) +1.		(hslots == 0) ifTrue: [ ^ nil ].		hpos := slotTable at: (slot << 1).				"Store the hash value"		khash := u.				"Locate the slot containing this key"		u := u >> 8.		u := u % hslots.		u := u << 3.		kpos := hpos + u.	].	"Search all of the hash slots for this key"	[loop < hslots] whileTrue: [ 		file position: kpos.		h := file nextByte bitOr: (file nextByte << 8) bitOr: (file nextByte << 16) bitOr: (file nextByte << 24). 		pos := file nextByte bitOr: (file nextByte << 8) bitOr: (file nextByte << 16) bitOr: (file nextByte << 24).		(pos == 0) ifTrue: [ ^ nil ]. 				"Advance the loop count and key position"		loop := loop +1.		kpos := kpos +8.		(kpos == (hpos + (hslots << 3))) ifTrue: [ kpos := hpos ].				"Ignore this entry if the hash values do not match"		(h ~= khash ) ifTrue: [ thisContext continue ].  				"Get the length of the key and data in this hash slot entry."		file position: pos.				klen := file nextByte bitOr: (file nextByte << 8) bitOr: (file nextByte << 16) bitOr: (file nextByte << 24).		(klen ~= key size ) ifTrue: [ thisContext continue ].		dlen := file nextByte bitOr: (file nextByte << 8) bitOr: (file nextByte << 16) bitOr: (file nextByte << 24).				"Read the key stored in this entry and compare it to the key we were given."		match := true.		k := ByteArray new: klen.		k := file nextBits: k size.		1 to: k size do: [ :i| 			(k at: i ~= key at: i) 				ifTrue: [ 					match := false.					"Break"				 ]		].				"No match check the next slot"		(match  == false ) ifTrue: [ thisContext continue ].				"The keys match, return the data"		d := ByteArray new: dlen.		d := file nextBits: d size.		^ d.	].	^ nil.! !!Cdb methodsFor: 'modal control' stamp: 'Kevingamelin 2/27/2016 14:22'!findstart: key	"Prepares the class to search for the given key"	loop := 0.! !!Cdb methodsFor: 'initialize' stamp: 'Anonymous 2/29/2016 11:16'!initialize: filepath	| table offset pos len |	super initialize.	"Creates an instance of the Cdb class and loads the given CDB file."	"Open the CDB file"	file := FileStream forceNewFileNamed: filepath.	file binary.		" Read and parse the slot table"	table := ByteArray new: 2048.	table := file nextByte: 2048. 		slotTable := IntegerArray new: 256*2.	offset := 0.	1 to: 256 do: [ :i| 		pos := (table at: offset+1 bitAnd: 16rff) 					bitOr: ((table at: offset+1 bitAnd: 16rff) <<  8)					bitOr: ((table at: offset+1 bitAnd: 16rff) <<  16)					bitOr: ((table at: offset+1 bitAnd: 16rff) <<  24).							len := (table at: offset+1 bitAnd: 16rff) 					bitOr: ((table at: offset+1 bitAnd: 16rff) <<  8)					bitOr: ((table at: offset+1 bitAnd: 16rff) <<  16)					bitOr: ((table at: offset+1 bitAnd: 16rff) <<  24).				slotTable at: i << 1 put: pos.		slotTable at: (i << 1) + 1 put: len.	].! !!Cdb methodsFor: 'getter' stamp: 'MaximeMAROINE 3/4/2016 14:11'!getFile^ file! !Object subclass: #CdbElement	instanceVariableNames: 'data key'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!CdbElement commentStamp: 'kevingamelin 2/26/2016 13:54' prior: 0!CdbElement represents a single element in a constant database.!!CdbElement methodsFor: 'initalize' stamp: 'MaximeMAROINE 3/4/2016 14:08'!configure:  k  and: d	super initialize.	"Creates an instance of the CdbElement class and initializes it with the given key and data values."	key := k.	data := d.! !!CdbElement methodsFor: 'getter' stamp: 'kevingamelin 2/26/2016 14:06'!getData	"The data value for this element."	^ data! !!CdbElement methodsFor: 'getter' stamp: 'kevingamelin 2/26/2016 14:06'!getKey	"The key value for this element."	^ key! !Object subclass: #CdbHashPointer	instanceVariableNames: 'hash pos'	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!CdbHashPointer commentStamp: 'Kevingamelin 2/26/2016 21:34' prior: 0!The hash value of this entry. !!CdbHashPointer methodsFor: 'getter' stamp: 'MaximeMAROINE 3/4/2016 14:44'!getPos^ pos! !!CdbHashPointer methodsFor: 'getter' stamp: 'MaximeMAROINE 3/4/2016 14:43'!getHash^ hash! !!CdbHashPointer methodsFor: 'initialize' stamp: 'MaximeMAROINE 3/4/2016 14:41'!configure: h and: p	super initialize.	"Creates a new CdbHashPointer and initializes it with the given hash value and position."	hash := h.	pos := p	! !Object subclass: #Core	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike'!!Core commentStamp: 'kevingamelin 2/26/2016 16:20' prior: 0!ALL core methode!!Core methodsFor: 'modal control' stamp: 'Kevingamelin 2/27/2016 14:15'!hash: key	"Computes and returns the hash value for the given key."	|  h l k |	h := 5381.	1 to: key size do: [ :i | 			l := h << 5.			h := h + ( 1 bitAnd: 16r00000000ffffffff).			h := h bitAnd: 16r00000000ffffffff.						k := key  at: i.			k := (k + 2r100) bitAnd: 16rff.			h := h raisedTo: k.	].	^ h bitAnd: 16r00000000ffffffff.! !TestCase subclass: #CdbElementTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike-Test'!!CdbElementTest methodsFor: 'getter' stamp: 'MaximeMAROINE 3/4/2016 14:09'!testConfigureAnd|c bA1 bA2|bA1 := ByteArray new.bA2 := ByteArray new.c := CdbElement new.c configure: bA1 and: bA2.self assert: c getKey == bA1.self assert: c getData == bA2.! !!CdbElementTest methodsFor: 'getter' stamp: 'maximemaroine 2/28/2016 13:37'!testGetkey|c|c := CdbElement new.self assert: c getKey = nil! !!CdbElementTest methodsFor: 'getter' stamp: 'maximemaroine 2/28/2016 13:36'!testGetData|c|c := CdbElement new.self assert: c getKey = nil! !TestCase subclass: #CdbHashPointerTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike-Test'!!CdbHashPointerTest methodsFor: 'initialize' stamp: 'MaximeMAROINE 3/4/2016 14:48'!testConfigureAnd|c|c := CdbHashPointer new configure: 10 and: 20.self assert: c getHash = 10.self assert: c getPos = 20! !!CdbHashPointerTest methodsFor: 'initialize' stamp: 'MaximeMAROINE 3/4/2016 14:44'!testInitialize|c|c := CdbHashPointer new configure: 10 and: 20.self assert: c getHash = 10.self assert: c getPos = 20! !!CdbHashPointerTest methodsFor: 'initialize' stamp: 'MaximeMAROINE 3/4/2016 14:58'!testGetPos|c|c := CdbHashPointer new configure: 10 and: 20.self assert: c getPos = 20! !!CdbHashPointerTest methodsFor: 'initialize' stamp: 'MaximeMAROINE 3/4/2016 14:56'!testGetHash|c|c := CdbHashPointer new configure: 10 and: 20.self assert: c getHash = 10! !TestCase subclass: #CdbTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'CDBFormatJavaLike-Test'!!CdbTest methodsFor: 'initialize' stamp: 'MaximeMAROINE 3/4/2016 14:35'!testInitialize|c|c := Cdb new initialize: '/home/l3/maroine/Documents/github/Licence3-Semestre6/OpenDevs/Ressources/example/basefile.cdb'.self assert: c getFile ~= nil.! !!CdbTest methodsFor: 'initialize' stamp: 'MaximeMAROINE 3/4/2016 14:36'!testClose|c|c := Cdb new initialize: '/home/l3/maroine/Documents/github/Licence3-Semestre6/OpenDevs/Ressources/example/basefile.cdb'.c close.self assert: c getFile = nil.! !