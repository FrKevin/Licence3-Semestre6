<!DOCTYPE html>
<!-- saved from url=(0063)http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<title>Interprétation</title>

<link href="./Interprétation_files/feuille.css" rel="stylesheet" type="text/css">
<meta name="viewport" content="initial-scale=1.0">
</head>
<body class="monocol">
<nav><a href="http://cristal.univ-lille.fr/~hym">recherche</a> – <a href="http://www.fil.univ-lille1.fr/~hym/">~</a>/<a href="http://www.fil.univ-lille1.fr/~hym/e">enseignements</a></nav>
<header>
<h1 class="titre">Interprétation</h1>

</header>
<div class="contenu">
  <p>L’objectif de ce TP est de mettre en œuvre un interprète pour un petit langage fonctionnel.</p>
<h2 id="déclaration-des-types-des-expressions">Déclaration des types des expressions</h2>
<p>Le type de données pour les expressions de notre petit langage est directement inspiré du type de données utilisé par GHC<a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fn1" class="footnoteRef" id="fnref1"><sup>1</sup></a>. Ces expressions sont celles du λ-calcul enrichi de <em>littéraux</em>. Nous autoriserons ainsi dans notre petit langage l’usage de nombres entiers et de booléens<a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fn2" class="footnoteRef" id="fnref2"><sup>2</sup></a>.</p>
<p>Nous partirons donc avec les déclarations de types suivantes&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Nom</span> <span class="fu">=</span> <span class="dt">String</span>

<span class="kw">data</span> <span class="dt">Expression</span> <span class="fu">=</span> <span class="dt">Lam</span> <span class="dt">Nom</span> <span class="dt">Expression</span>
                <span class="fu">|</span> <span class="dt">App</span> <span class="dt">Expression</span> <span class="dt">Expression</span>
                <span class="fu">|</span> <span class="dt">Var</span> <span class="dt">Nom</span>
                <span class="fu">|</span> <span class="dt">Lit</span> <span class="dt">Litteral</span>
                <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>)

<span class="kw">data</span> <span class="dt">Litteral</span> <span class="fu">=</span> <span class="dt">Entier</span> <span class="dt">Integer</span>
              <span class="fu">|</span> <span class="dt">Bool</span>   <span class="dt">Bool</span>
              <span class="kw">deriving</span> (<span class="dt">Show</span>,<span class="dt">Eq</span>)</code></pre></div>
<p>Prenons quelques exemples de représentation pour clarifier ces types. Voici une liste d’expressions (écrites en utilisant la syntaxe de Haskell) et leur représentation (de type <code class="sourceCode haskell"><span class="dt">Expression</span></code>)&nbsp;:</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Expression</th>
<th style="text-align: left;">Représentation</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode haskell">a</code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">Var</span> <span class="st">"a"</span></code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode haskell">\x <span class="ot">-&gt;</span> x</code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">Var</span> <span class="st">"x"</span>)</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">True</span></code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">Lit</span> (<span class="dt">Bool</span> <span class="dt">True</span>)</code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode haskell">not <span class="dt">True</span></code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"not"</span>) (<span class="dt">Lit</span> (<span class="dt">Bool</span> <span class="dt">True</span>))</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode haskell">add</code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">Var</span> <span class="st">"add"</span></code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode haskell">add <span class="dv">12</span></code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"add"</span>) (<span class="dt">Lit</span> (<span class="dt">Entier</span> <span class="dv">12</span>))</code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode haskell">add <span class="dv">12</span> <span class="dv">34</span></code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"add"</span>) (<span class="dt">Lit</span> (<span class="dt">Entier</span> <span class="dv">12</span>))) (<span class="dt">Lit</span> (<span class="dt">Entier</span> <span class="dv">34</span>))</code></td>
</tr>
</tbody>
</table>
<p>Comme il est rapidement fastidieux d’écrire des expressions en utilisant cette représentation, nous allons commencer notre travail par un petit analyseur syntaxique.</p>
<h2 id="analyse-syntaxique-dexpressions">Analyse syntaxique d’expressions</h2>
<p>Pour écrire un analyseur syntaxique pour les petites expressions, nous utiliserons les constructions vues en cours, avec de légères modifications.</p>
<h3 id="module-parser">Module <code class="sourceCode haskell"><span class="dt">Parser</span></code></h3>
<p>Vous utiliserez le module <a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/Parser.hs">Parser</a>, en plaçant le fichier <code>Parser.hs</code> dans le même répertoire que votre fichier <code>Interprete.hs</code>, par exemple, et en ajoutant</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import </span><span class="dt">Parser</span></code></pre></div>
<p>au début de votre fichier. Quand vous chargerez votre fichier par <code class="sourceCode haskell"><span class="fu">:</span>load Interprete.hs</code> dans GHCi, il ira aussi charger le module <code class="sourceCode haskell"><span class="dt">Parser</span></code>.</p>
<p>Les différences entre <code>Parser.hs</code> et le code écrit en cours sont les suivantes&nbsp;:</p>
<ul>
<li>le combinateur séquentiel est noté <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> (il était noté <code class="sourceCode haskell"><span class="fu">&gt;&gt;&gt;</span></code> en cours),</li>
<li>le fait que <code class="sourceCode haskell"><span class="dt">Parser</span></code> est une instance de <code class="sourceCode haskell"><span class="dt">Monad</span></code> est explicité&nbsp;: cela permet d’utiliser la notation <code class="sourceCode haskell"><span class="kw">do</span></code> illustrée en cours pour la monade&nbsp;<code class="sourceCode haskell"><span class="dt">IO</span></code>.</li>
</ul>
<p>Par ailleurs, dans la suite de l’énoncé, on utilise en général <code class="sourceCode haskell">return</code> pour le parseur qui réussit toujours et retourne une constante (il était noté <code class="sourceCode haskell">reussit</code> en cours). Les deux sont équivalents dans le module <code class="sourceCode haskell"><span class="dt">Parser</span></code>.</p>
<p>Quelques exemples illustreront mieux les différences. L’analyseur syntaxique qui retrouve une chaîne de caractères précise peut ainsi s’écrire&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">chaine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
chaine <span class="st">""</span>     <span class="fu">=</span> return <span class="st">""</span>
chaine (c<span class="fu">:</span>cs) <span class="fu">=</span> car c           <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
                chaine cs       <span class="fu">&gt;&gt;=</span> \_ <span class="ot">-&gt;</span>
                return (c<span class="fu">:</span>cs)</code></pre></div>
<p>mais surtout, il peut être écrit de façon plus concise en utilisant <code class="sourceCode haskell"><span class="kw">do</span></code>&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">chaine ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Parser</span> <span class="dt">String</span>
chaine <span class="st">""</span>     <span class="fu">=</span> return <span class="st">""</span>
chaine (c<span class="fu">:</span>cs) <span class="fu">=</span> <span class="kw">do</span> car c
                   chaine cs
                   return (c<span class="fu">:</span>cs)</code></pre></div>
<p>De même, <code class="sourceCode haskell">unOuPlus</code> peut s’écrire soit ainsi&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unOuPlus ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
unOuPlus p <span class="fu">=</span> p               <span class="fu">&gt;&gt;=</span> \r <span class="ot">-&gt;</span>
             zeroOuPlus p    <span class="fu">&gt;&gt;=</span> \rs <span class="ot">-&gt;</span>
             return (r<span class="fu">:</span>rs)</code></pre></div>
<p>soit, avec <code class="sourceCode haskell"><span class="kw">do</span></code>&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">unOuPlus ::</span> <span class="dt">Parser</span> a <span class="ot">-&gt;</span> <span class="dt">Parser</span> [a]
unOuPlus p <span class="fu">=</span> <span class="kw">do</span> r <span class="ot">&lt;-</span> p
                rs <span class="ot">&lt;-</span> zeroOuPlus p
                return (r<span class="fu">:</span>rs)</code></pre></div>
<p>Dans la suite vous pourrez donc utiliser la syntaxe que vous préférez. Cependant, prenez garde à l’indentation de votre code quand vous utilisez <code class="sourceCode haskell"><span class="kw">do</span></code>&nbsp;: dans la fonction <code class="sourceCode haskell">unOuPlus</code> ci-dessus, il est primordial que les <code>r</code> soient alignés. Utilisez donc des espaces pour indenter votre code pour éviter les mauvaises surprises avec les tabulations.</p>
<p>Autre point&nbsp;: le module <code class="sourceCode haskell"><span class="dt">Parser</span></code> fourni a un entête&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">module</span> <span class="dt">Parser</span> ( <span class="dt">Parser</span>
              , <span class="dt">Resultat</span>
              , runParser
              , unCaractereQuelconque
              , echoue
              , reussit
              , (<span class="fu">|||</span>)
              , carCond
              , car
              , chaine
              , unOuPlus
              , zeroOuPlus
              , complet
              , resultat )
<span class="kw">where</span></code></pre></div>
<p>qui précise explicitement ce qui est exporté par le module. Notez que cette liste ne mentionne pas <code class="sourceCode haskell"><span class="dt">MkParser</span></code>&nbsp;: le type des parseurs est abstrait à l’extérieur du module, la seule façon de construire des parseurs sera donc d’utiliser les briques de base et les combinateurs.</p>
<h3 id="analyse-proprement-dite">Analyse proprement dite</h3>
<p>Nous voulons autoriser des espaces à plusieurs endroits des expressions.</p>
<ol type="1">
<li><p>Définissez un analyseur syntaxique <code class="sourceCode haskell"><span class="ot">espacesP ::</span> <span class="dt">Parser</span> ()</code> qui consomme tous les espaces au début de la chaîne à analyser, et retourne toujours <code class="sourceCode haskell">()</code> pour ignorer ces espaces.</p>
<p>Par exemple&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse espacesP <span class="st">""</span>
<span class="dt">Just</span> ((),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse espacesP <span class="st">" "</span>
<span class="dt">Just</span> ((),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse espacesP <span class="st">"     "</span>
<span class="dt">Just</span> ((),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse espacesP <span class="st">"  a "</span>
<span class="dt">Just</span> ((),<span class="st">"a "</span>)</code></pre></div></li>
</ol>
<p>Commençons par analyser les expressions les plus simples possibles&nbsp;: les variables. Pour simplifier, nous considérerons que les noms de variables sont juste des suites de lettres minuscules (sans accent).</p>
<ol start="2" type="1">
<li><p>Définissez un analyseur syntaxique <code class="sourceCode haskell"><span class="ot">nomP ::</span> <span class="dt">Parser</span> <span class="dt">Nom</span></code> qui analyse le premier nom apparaissant dans la chaîne.</p>
<p>Pour traiter correctement les espaces dans la suite, ce parseur consommera aussi tous les espaces qui suivent le nom (il utilisera pour cela <code class="sourceCode haskell">espacesP</code>). Mais il échouera si la chaîne commence par des espaces (quand on combinera deux analyseurs, le premier se chargera de consommer les espaces du milieu).</p>
<p>Par exemple&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse nomP <span class="st">""</span>
<span class="dt">Nothing</span>
ghci<span class="fu">&gt;</span> parse nomP <span class="st">"abc"</span>
<span class="dt">Just</span> (<span class="st">"abc"</span>,<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse nomP <span class="st">"abc def"</span>
<span class="dt">Just</span> (<span class="st">"abc"</span>,<span class="st">"def"</span>)
ghci<span class="fu">&gt;</span> parse nomP <span class="st">"abc    "</span>
<span class="dt">Just</span> (<span class="st">"abc"</span>,<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse nomP <span class="st">"abc   def"</span>
<span class="dt">Just</span> (<span class="st">"abc"</span>,<span class="st">"def"</span>)
ghci<span class="fu">&gt;</span> parse nomP <span class="st">" abc"</span>
<span class="dt">Nothing</span></code></pre></div></li>
<li><p>Définissez un analyseur syntaxique <code class="sourceCode haskell"><span class="ot">varP ::</span> <span class="dt">Parser</span> <span class="dt">Expression</span></code>.</p>
<p>Par exemple&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse varP <span class="st">""</span>
<span class="dt">Nothing</span>
ghci<span class="fu">&gt;</span> parse varP <span class="st">"abc"</span>
<span class="dt">Just</span> (<span class="dt">Var</span> <span class="st">"abc"</span>,<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse varP <span class="st">"abc def"</span>
<span class="dt">Just</span> (<span class="dt">Var</span> <span class="st">"abc"</span>,<span class="st">"def"</span>)
ghci<span class="fu">&gt;</span> parse varP <span class="st">"abc    "</span>
<span class="dt">Just</span> (<span class="dt">Var</span> <span class="st">"abc"</span>,<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse varP <span class="st">" abc"</span>
<span class="dt">Nothing</span></code></pre></div></li>
<li>Définissez une fonction <code class="sourceCode haskell"><span class="ot">applique ::</span> [<span class="dt">Expression</span>] <span class="ot">-&gt;</span> <span class="dt">Expression</span></code> telle que&nbsp;:
<ul>
<li><code class="sourceCode haskell">applique []</code> n’est pas définie,</li>
<li><code class="sourceCode haskell">applique [e]</code> vale <code class="sourceCode haskell">e</code>,</li>
<li><code class="sourceCode haskell">applique [e1, e2]</code> vale <code class="sourceCode haskell"><span class="dt">App</span> e1 e2</code>,</li>
<li><code class="sourceCode haskell">applique [e1, e2, e3]</code> vale <code class="sourceCode haskell"><span class="dt">App</span> (<span class="dt">App</span> e1 e2) e3</code>,</li>
<li>etc.</li>
</ul>
<p>(Dans la famille des fonctions <em>fold</em> de <code class="sourceCode haskell"><span class="dt">Data.List</span></code> vous trouverez une fonction qui fait tout le travail. La définition récursive n’est pas très longue non plus.)</p></li>
<li>Définissez deux analyseurs syntaxiques <code class="sourceCode haskell"><span class="ot">exprP ::</span> <span class="dt">Parser</span> <span class="dt">Expression</span></code> et <code class="sourceCode haskell"><span class="ot">exprsP ::</span> <span class="dt">Parser</span> <span class="dt">Expression</span></code> tels que&nbsp;:
<ul>
<li>pour l’instant <code class="sourceCode haskell">exprP</code> soit équivalent à <code class="sourceCode haskell">varP</code>,</li>
<li><code class="sourceCode haskell">exprsP</code> parse une suite de une ou plusieurs expressions (chacune parsées par <code class="sourceCode haskell">exprP</code>) et les combine en une expression par la fonction <code class="sourceCode haskell">applique</code><a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fn3" class="footnoteRef" id="fnref3"><sup>3</sup></a>.</li>
</ul>
<p>Par exemple&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse exprsP <span class="st">""</span>
<span class="dt">Nothing</span>
ghci<span class="fu">&gt;</span> parse exprsP <span class="st">"a"</span>
<span class="dt">Just</span> (<span class="dt">Var</span> <span class="st">"a"</span>,<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse exprsP <span class="st">"a    "</span>
<span class="dt">Just</span> (<span class="dt">Var</span> <span class="st">"a"</span>,<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse exprsP <span class="st">"a b"</span>
<span class="dt">Just</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"a"</span>) (<span class="dt">Var</span> <span class="st">"b"</span>),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse exprsP <span class="st">"a b c"</span>
<span class="dt">Just</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"a"</span>) (<span class="dt">Var</span> <span class="st">"b"</span>)) (<span class="dt">Var</span> <span class="st">"c"</span>),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse exprsP <span class="st">"a b c d"</span>
<span class="dt">Just</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"a"</span>) (<span class="dt">Var</span> <span class="st">"b"</span>)) (<span class="dt">Var</span> <span class="st">"c"</span>)) (<span class="dt">Var</span> <span class="st">"d"</span>),<span class="st">""</span>)</code></pre></div></li>
<li><p>Définissez un analyseur syntaxique <code class="sourceCode haskell"><span class="ot">lambdaP ::</span> <span class="dt">Parser</span> <span class="dt">Expression</span></code> qui reconnaisse une λ-expression utilisant la syntaxe suivante inspirée de Haskell&nbsp;: <code class="sourceCode haskell">\ x <span class="ot">-&gt;</span> e</code> où <code class="sourceCode haskell">e</code> sera parsé par <code class="sourceCode haskell">exprsP</code>.</p>
<p>Par exemple&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse lambdaP <span class="st">"\\ x -&gt; x"</span>
<span class="dt">Just</span> (<span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">Var</span> <span class="st">"x"</span>),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse lambdaP <span class="st">"\\ x -&gt; x x"</span>
<span class="dt">Just</span> (<span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"x"</span>) (<span class="dt">Var</span> <span class="st">"x"</span>)),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse lambdaP <span class="st">"\\ x -&gt; x x  "</span>
<span class="dt">Just</span> (<span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"x"</span>) (<span class="dt">Var</span> <span class="st">"x"</span>)),<span class="st">""</span>)</code></pre></div>
<p>Notez en particulier que le caractère <code>\</code> s’écrit littéralement <code class="sourceCode haskell"><span class="ch">'\\'</span></code> en Haskell, car il sert d’échappement.</p>
<p>Vous pourrez bien entendu étendre la syntaxe pour utiliser aussi une autre notation, par exemple pour parser aussi <code class="sourceCode haskell"><span class="st">"λx → x"</span></code>, etc., si vous le voulez.</p></li>
<li><p>Étendez la définition de <code class="sourceCode haskell">exprP</code> pour que</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse exprP <span class="st">"\\x -&gt; x"</span>
<span class="dt">Just</span> (<span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">Var</span> <span class="st">"x"</span>),<span class="st">""</span>)</code></pre></div></li>
<li><p>Définissez un analyseur syntaxique <code class="sourceCode haskell"><span class="ot">exprParentheseeP ::</span> <span class="dt">Parser</span> <span class="dt">Expression</span></code> tel que&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse exprParentheseeP <span class="st">"()"</span>
<span class="dt">Nothing</span>
ghci<span class="fu">&gt;</span> parse exprParentheseeP <span class="st">"(x)"</span>
<span class="dt">Just</span> (<span class="dt">Var</span> <span class="st">"x"</span>,<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse exprParentheseeP <span class="st">"(x y)"</span>
<span class="dt">Just</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"x"</span>) (<span class="dt">Var</span> <span class="st">"y"</span>),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse exprParentheseeP <span class="st">"(\\x -&gt; x)"</span>
<span class="dt">Just</span> (<span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">Var</span> <span class="st">"x"</span>),<span class="st">""</span>)</code></pre></div>
<p>Étendez <code class="sourceCode haskell">exprP</code> pour que les expressions parenthésées soient acceptées comme des expressions. Ainsi, vous aurez&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse exprP <span class="st">"(\\x -&gt; x) y"</span>
<span class="dt">Just</span> (<span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">Var</span> <span class="st">"x"</span>),<span class="st">"y"</span>)
ghci<span class="fu">&gt;</span> parse exprsP <span class="st">"(\\x -&gt; x) y"</span>
<span class="dt">Just</span> (<span class="dt">App</span> (<span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">Var</span> <span class="st">"x"</span>)) (<span class="dt">Var</span> <span class="st">"y"</span>),<span class="st">""</span>)

ghci<span class="fu">&gt;</span> parse exprP <span class="st">"\\x -&gt; x y"</span>
<span class="dt">Just</span> (<span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"x"</span>) (<span class="dt">Var</span> <span class="st">"y"</span>)),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse exprsP <span class="st">"\\x -&gt; x y"</span>
<span class="dt">Just</span> (<span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">App</span> (<span class="dt">Var</span> <span class="st">"x"</span>) (<span class="dt">Var</span> <span class="st">"y"</span>)),<span class="st">""</span>)</code></pre></div></li>
<li><p>Définissez un analyseur syntaxique <code class="sourceCode haskell"><span class="ot">nombreP ::</span> <span class="dt">Parser</span> <span class="dt">Expression</span></code>&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse nombreP <span class="st">"123"</span>
<span class="dt">Just</span> (<span class="dt">Lit</span> (<span class="dt">Entier</span> <span class="dv">123</span>),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse nombreP <span class="st">"  123"</span>
<span class="dt">Nothing</span>
ghci<span class="fu">&gt;</span> parse nombreP <span class="st">"123  "</span>
<span class="dt">Just</span> (<span class="dt">Lit</span> (<span class="dt">Entier</span> <span class="dv">123</span>),<span class="st">""</span>)</code></pre></div></li>
<li><p>Définissez un analyseur syntaxique <code class="sourceCode haskell"><span class="ot">booleenP ::</span> <span class="dt">Parser</span> <span class="dt">Expression</span></code>&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> parse booleenP <span class="st">"True"</span>
<span class="dt">Just</span> (<span class="dt">Lit</span> (<span class="dt">Bool</span> <span class="dt">True</span>),<span class="st">""</span>)
ghci<span class="fu">&gt;</span> parse booleenP <span class="st">"False"</span>
<span class="dt">Just</span> (<span class="dt">Lit</span> (<span class="dt">Bool</span> <span class="dt">False</span>),<span class="st">""</span>)</code></pre></div>
<p>Ajoutez les nombres et les booléens à <code class="sourceCode haskell">exprP</code>.</p></li>
<li><p>Peaufinez le tout en définissant un analyseur syntaxique <code class="sourceCode haskell"><span class="ot">expressionP ::</span> <span class="dt">Parser</span> <span class="dt">Expression</span></code> correspondant à <code class="sourceCode haskell">exprsP</code> éventuellement précédé d’espaces.</p></li>
</ol>
<p>Dans la suite, nous allons interpréter des expressions. Commençons donc par une simple fonction pour combiner tout le travail précédent.</p>
<ol start="12" type="1">
<li><p>Définissez une fonction au nom court, disons <code class="sourceCode haskell">ras</code> (<em>r</em>ésultat de l’<em>a</em>nalyse <em>s</em>yntaxique), pour faire toute l’analyse&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">ras ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span></code></pre></div>
<p>Cette fonction échouera (par exemple par un <code class="sourceCode haskell">error <span class="st">"Erreur d’analyse syntaxique"</span></code>) si l’analyse syntaxique échoue ou si elle n’a pas analysé la chaîne complète.</p></li>
</ol>
<h2 id="interprétation">Interprétation</h2>
<p><em>Remarque&nbsp;: Il est possible de traiter cette section sans avoir d’analyse syntaxique fonctionnelle, mais il faudra du coup saisir les <code class="sourceCode haskell"><span class="dt">Expression</span></code> directement, ce qui est rapidement fastidieux…</em></p>
<p>Pour éviter les ambiguïtés entre <code>\</code> et <code>\\</code> suivant que l’on parle d’une expression ou de sa représentation dans une chaîne de caractères dans le code Haskell, nous utiliserons dans la suite <code class="sourceCode haskell">λ</code>.</p>
<p>Interpréter une expression de notre mini-langage fonctionnel signifie simplement appliquer chaque fonction à son argument jusqu’à ce qu’il n’y ait plus de <em>rédex</em> (expression réductible, c’est-à-dire justement une fonction appliquée à un argument). Les différentes fonctions d’interprétation que nous allons mettre au point convertiront ainsi une expression en une <em>valeur</em>.</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">Expression</th>
<th style="text-align: left;">Valeur</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dv">12</span></code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dv">12</span></code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">True</span></code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dt">True</span></code></td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode haskell">(λx <span class="ot">-&gt;</span> x) <span class="dv">12</span></code></td>
<td style="text-align: left;"><code class="sourceCode haskell"><span class="dv">12</span></code></td>
</tr>
<tr class="even">
<td style="text-align: left;"><code class="sourceCode haskell">(λx <span class="ot">-&gt;</span> x)</code></td>
<td style="text-align: left;">Une valeur correspondant à cette fonction</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><code class="sourceCode haskell">a</code></td>
<td style="text-align: left;">Échec, si <code class="sourceCode haskell">a</code> n’est pas défini</td>
</tr>
</tbody>
</table>
<h3 id="interprète-simple">Interprète simple</h3>
<p>Nous avons tout d’abord besoin de définir ce que nous appellerons une valeur. Nous allons profiter du fait qu’Haskell est lui-même un langage fonctionnel pour donner un type simple aux valeurs fonctionnelles de notre langage&nbsp;: nous utiliserons directement des fonctions&nbsp;!</p>
<p>Nous aurons donc deux sortes de valeurs&nbsp;: des littéraux et des fonctions.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ValeurA</span> <span class="fu">=</span> <span class="dt">VLitteralA</span> <span class="dt">Litteral</span>
             <span class="fu">|</span> <span class="dt">VFonctionA</span> (<span class="dt">ValeurA</span> <span class="ot">-&gt;</span> <span class="dt">ValeurA</span>)</code></pre></div>
<p>(nous utilisons le suffixe <code class="sourceCode haskell"><span class="dt">A</span></code> parce que nous allons mettre au point des variantes dans la suite).</p>
<p>Notez au passage que, en choisissant ce type pour les valeurs, nous avons choisi de donner une interprétation <em>stricte</em> à notre langage, c’est-à-dire en évaluation <em>par valeur</em>&nbsp;: l’argument que prend une fonction est une <code class="sourceCode haskell"><span class="dt">ValeurA</span></code> (et non pas une expression non encore évaluée). Ce choix simplifie l’interprète.</p>
<p>Malheureusement, nous ne pouvons pas demander à Haskell de générer automatiquement du code pour afficher ces <code class="sourceCode haskell"><span class="dt">ValeurA</span></code>.</p>
<ol start="13" type="1">
<li><p>Essayez tout de même d’ajouter&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">             <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>Comprenez-vous le problème&nbsp;?</p></li>
</ol>
<p>Nous allons donc donner une instance de la classe <code class="sourceCode haskell"><span class="dt">Show</span></code> à la main. Comme l’indique la documentation de la classe <code class="sourceCode haskell"><span class="dt">Show</span></code> définie dans le <code class="sourceCode haskell"><span class="dt">Prelude</span></code> (consultez cette documentation&nbsp;!), il suffit de définir soit <code class="sourceCode haskell">showsPrec</code> soit <code class="sourceCode haskell">show</code> pour avoir une définition complète. Nous nous contenterons ici de définir <code class="sourceCode haskell">show</code>. Pour le type <code class="sourceCode haskell"><span class="dt">ValeurA</span></code>, cette fonction aura donc le type <code class="sourceCode haskell"><span class="dt">ValeurA</span> <span class="ot">-&gt;</span> <span class="dt">String</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Show</span> <span class="dt">ValeurA</span> <span class="kw">where</span>
    show (<span class="dt">VFonctionA</span> _) <span class="fu">=</span> <span class="st">"λ"</span>
                       <span class="co">-- ^ ou "VFonctionA _", ou "&lt;fun&gt;" ou toute</span>
                       <span class="co">--   autre représentation des fonctions</span>
    show (<span class="dt">VLitteralA</span> …
    …</code></pre></div>
<ol start="14" type="1">
<li><p>Complétez la définition de l’instance <code class="sourceCode haskell"><span class="dt">Show</span></code> pour <code class="sourceCode haskell"><span class="dt">ValeurA</span></code>.</p>
<p>Vérifiez que vous pouvez afficher des <code class="sourceCode haskell"><span class="dt">ValeurA</span></code> dans GHCi sans vous faire insulter&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="dt">VFonctionA</span> undefined
λ
<span class="ot">it ::</span> <span class="dt">ValeurA</span>
ghci<span class="fu">&gt;</span> <span class="dt">VLitteralA</span> (<span class="dt">Entier</span> <span class="dv">12</span>)
<span class="dv">12</span>
<span class="ot">it ::</span> <span class="dt">ValeurA</span>
ghci<span class="fu">&gt;</span> <span class="dt">VLitteralA</span> (<span class="dt">Bool</span> <span class="dt">True</span>)
<span class="dt">True</span>
<span class="ot">it ::</span> <span class="dt">ValeurA</span></code></pre></div></li>
</ol>
<p>Bien entendu, les réponses doivent correspondre au format que vous aurez choisi. Nous avons choisi de représenter dans les exemples de cet énoncé les littéraux simplement comme leur contenu pour avoir l’affichage le plus compact possible, le type levant toute ambiguïté.</p>
<p>Interpréter les littéraux, c’est-à-dire convertir les expressions <code class="sourceCode haskell"><span class="dt">Lit</span> …</code> en valeurs, ne va donc poser aucun problème.</p>
<p>Interpréter les fonctions est plus difficile. Nous voulons associer à l’expression <code class="sourceCode haskell">(λx <span class="ot">-&gt;</span> x)</code>, c’est-à-dire <code class="sourceCode haskell"><span class="dt">Lam</span> <span class="st">"x"</span> (<span class="dt">Var</span> <span class="st">"x"</span>)</code>, une <code class="sourceCode haskell"><span class="dt">VFonctionA</span> f</code> où <code class="sourceCode haskell">f (<span class="dt">VLitteralA</span> (<span class="dt">Bool</span> <span class="dt">True</span>))</code> devra valoir <code class="sourceCode haskell"><span class="dt">VLitteralA</span> (<span class="dt">Bool</span> <span class="dt">True</span>)</code>. Pour arriver à cette fin, <code class="sourceCode haskell">f</code> doit déclencher l’interprète sur l’expression <code class="sourceCode haskell"><span class="dt">Var</span> <span class="st">"x"</span></code> en se «&nbsp;souvenant&nbsp;» que son paramètre&nbsp;<code class="sourceCode haskell">x</code> est associé à la valeur reçue en argument. Pour cela, nous utiliserons un <em>environnement</em>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Environnement</span> a <span class="fu">=</span> [(<span class="dt">Nom</span>, a)]</code></pre></div>
<p>Un environnement de type <code class="sourceCode haskell"><span class="dt">Environnement</span> <span class="dt">ValeurA</span></code> est donc une liste d’associations de valeurs à des noms.</p>
<p>Interpréter une variable reviendra juste à aller chercher sa valeur dans l’environnement. (Vous irez piocher les fonctions standard dont vous aurez besoin, par exemple <code class="sourceCode haskell">lookup</code>&nbsp;; pensez à regarder les modules <code class="sourceCode haskell"><span class="dt">Data.List</span></code>, <code class="sourceCode haskell"><span class="dt">Data.Maybe</span></code>, etc. et pas seulement les fonctions du <code class="sourceCode haskell"><span class="dt">Prelude</span></code>).</p>
<p>Enfin, pour interpréter l’application <code class="sourceCode haskell"><span class="dt">App</span> e e'</code>, il suffit d’interpréter&nbsp;<code class="sourceCode haskell">e</code> et&nbsp;<code class="sourceCode haskell">e'</code>. <code class="sourceCode haskell">e</code> doit naturellement s’interpréter comme une <code class="sourceCode haskell"><span class="dt">VFonctionA</span> f</code>&nbsp;: il suffit alors d’appliquer la fonction&nbsp;<code class="sourceCode haskell">f</code> à l’interprétation de&nbsp;<code class="sourceCode haskell">e'</code>.</p>
<ol start="15" type="1">
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">interpreteA ::</span> <span class="dt">Environnement</span> <span class="dt">ValeurA</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">ValeurA</span></code>.</p>
<p>Vérifiez que vous obtenez le résultat attendu sur un certain nombre d’expressions, notamment&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteA [] (ras <span class="st">"12"</span>)
<span class="dv">12</span>
ghci<span class="fu">&gt;</span> interpreteA [] (ras <span class="st">"True"</span>)
<span class="dt">True</span>
ghci<span class="fu">&gt;</span> interpreteA [] (ras <span class="st">"λx -&gt; x"</span>)
λ
ghci<span class="fu">&gt;</span> interpreteA [] (ras <span class="st">"(λx -&gt; x) 12"</span>)
<span class="dv">12</span>
ghci<span class="fu">&gt;</span> interpreteA [] (ras <span class="st">"x"</span>)
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> <span class="dt">Maybe</span><span class="fu">.</span>fromJust<span class="fu">:</span> <span class="dt">Nothing</span>
ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"x"</span>, <span class="dt">VLitteralA</span> (<span class="dt">Entier</span> <span class="dv">45</span>))] (ras <span class="st">"x"</span>)
<span class="dv">45</span>
ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"x"</span>, <span class="dt">VLitteralA</span> (<span class="dt">Entier</span> <span class="dv">45</span>))] (ras <span class="st">"(λx -&gt; x) 67"</span>)
<span class="dv">67</span>
ghci<span class="fu">&gt;</span> interpreteA [] (ras <span class="st">"(λx -&gt; x x)(λx -&gt; x x)"</span>)
<span class="fu">^</span><span class="dt">CInterrupted</span><span class="fu">.</span></code></pre></div>
<p>Dans le cas où on essaie d’interpréter une variable qui n’apparaît pas dans l’environnement, l’interprète pourra échouer de la façon qui vous arrange.</p></li>
</ol>
<h3 id="quelques-primitives-pour-un-langage-moins-primitif">Quelques primitives, pour un langage moins primitif</h3>
<p>Outre le fait d’être très utile pour interpréter les fonctions, l’environnement peut contenir des <em>primitives</em>, des valeurs qui ne sont pas forcément exprimables dans le langage. En particulier, dans notre mini-langage, nous n’avons pas de façon de manipuler les littéraux. Mais ces manipulations peuvent s’exprimer en Haskell, bien entendu.</p>
<ol start="16" type="1">
<li><p>Définissez une fonction <code class="sourceCode haskell"><span class="ot">negA ::</span> <span class="dt">ValeurA</span></code> telle que&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"neg"</span>, negA)] (ras <span class="st">"neg 12"</span>)
<span class="fu">-</span><span class="dv">12</span>
ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"neg"</span>, negA)] (ras <span class="st">"neg"</span>)
λ</code></pre></div>
<p>Cette fonction pourra bien entendu échouer comme ça vous arrange dans le cas où elle n’est pas appliquée à un entier, par exemple&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"neg"</span>, negA)] (ras <span class="st">"neg True"</span>)
<span class="fu">***</span> <span class="dt">Exception</span><span class="fu">:</span> Interprete.hs<span class="fu">:</span><span class="dv">92</span><span class="fu">:</span><span class="dv">20</span><span class="fu">-</span><span class="dv">71</span><span class="fu">:</span> <span class="dt">Non</span><span class="fu">-</span>exhaustive patterns <span class="kw">in</span> lambda</code></pre></div></li>
<li><p>Définissez une fonction <code class="sourceCode haskell"><span class="ot">addA ::</span> <span class="dt">ValeurA</span></code> telle que&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"add"</span>, addA)] (ras <span class="st">"add"</span>)
λ
ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"add"</span>, addA)] (ras <span class="st">"add 12"</span>)
λ
ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"add"</span>, addA)] (ras <span class="st">"add 12 23"</span>)
<span class="dv">35</span></code></pre></div></li>
</ol>
<p>On voit bien que l’on pourrait définir les quatre opérations arithmétiques de même, avec un code quasiment identique.</p>
<ol start="18" type="1">
<li><p>Définissez une fonction <code class="sourceCode haskell"><span class="ot">releveBinOpEntierA ::</span> (<span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>) <span class="ot">-&gt;</span> <span class="dt">ValeurA</span></code> qui prend en argument un opérateur binaire sur les entiers et en fait une <code class="sourceCode haskell"><span class="dt">ValeurA</span></code>.</p>
<p>En définissant alors</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">envA ::</span> <span class="dt">Environnement</span> <span class="dt">ValeurA</span>
envA <span class="fu">=</span> [ (<span class="st">"neg"</span>,   negA)
       , (<span class="st">"add"</span>,   releveBinOpEntierA (<span class="fu">+</span>))
       , (<span class="st">"soust"</span>, releveBinOpEntierA (<span class="fu">-</span>))
       , (<span class="st">"mult"</span>,  releveBinOpEntierA (<span class="fu">*</span>))
       , (<span class="st">"quot"</span>,  releveBinOpEntierA quot) ]</code></pre></div>
<p>vous aurez&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteA envA (ras <span class="st">"soust 5 3"</span>)
<span class="dv">2</span>
ghci<span class="fu">&gt;</span> interpreteA envA (ras <span class="st">"mult 12 4"</span>)
<span class="dv">48</span>
ghci<span class="fu">&gt;</span> interpreteA envA (ras <span class="st">"quot (mult 12 4) 2"</span>)
<span class="dv">24</span>
ghci<span class="fu">&gt;</span> interpreteA envA (ras <span class="st">"quot (mult 12 4) 5"</span>)
<span class="dv">9</span></code></pre></div></li>
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">ifthenelseA ::</span> <span class="dt">ValeurA</span></code> telle que&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"if"</span>, ifthenelseA)] (ras <span class="st">"if True 1 2"</span>)
<span class="dv">1</span>
ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"if"</span>, ifthenelseA)] (ras <span class="st">"if False 1 2"</span>)
<span class="dv">2</span>
ghci<span class="fu">&gt;</span> interpreteA [(<span class="st">"if"</span>, ifthenelseA)] (ras <span class="st">"if True 1"</span>)
λ</code></pre></div></li>
</ol>
<h3 id="boucle-dinteraction">Boucle d’interaction</h3>
<p>Une boucle d’interaction répète les étapes suivantes jusqu’à la fin de son entrée standard&nbsp;:</p>
<ul>
<li>elle affiche une invite, disons <code class="sourceCode haskell"><span class="st">"minilang&gt; "</span></code> (<code class="sourceCode haskell">putStr</code> par exemple),</li>
<li>elle lit sur son entrée standard une ligne tapée par l’utilisateur (<code class="sourceCode haskell">getLine</code>),</li>
<li>elle affiche le résultat de l’interprète sur l’expression analysée dans la ligne.</li>
</ul>
<p>Vous pourrez utiliser les fonctions de <code class="sourceCode haskell"><span class="dt">System.IO</span></code>, notamment <code class="sourceCode haskell">isEOF</code>, et toutes les autres fonctions standard qui vous sembleront utiles.</p>
<ol start="20" type="1">
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">main ::</span> <span class="dt">IO</span> ()</code> pour implémenter une boucle d’interaction.</p>
<p>Vous pourrez l’utiliser de la façon suivante&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="kw">ghc</span> --make Interprete
…

$ <span class="kw">rlwrap</span> ./Interprete
…</code></pre></div></li>
</ol>
<h3 id="interprète-avec-erreurs">Interprète avec erreurs</h3>
<p>L’interprète simple précédent est sans pitié dans les cas d’erreurs, par exemple pour les expressions <code class="sourceCode haskell"><span class="dv">1</span> <span class="dv">2</span></code> (où <code class="sourceCode haskell"><span class="dv">1</span></code> n’est pas une fonction et ne peut donc pas être appliquée à <code class="sourceCode haskell"><span class="dv">2</span></code>), ou quand il tombe sur une variable qui n’est pas définie, ou quand il trouve une addition appliquée à d’autres arguments que des entiers, etc.</p>
<p>Plutôt que des exceptions qui cassent l’interprétation, nous allons permettre à notre interprète de retourner une erreur.</p>
<p>Une solution serait de définir&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpreteB ::</span> <span class="dt">Environnement</span> <span class="dt">ValeurB</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">Maybe</span> <span class="dt">ValeurB</span></code></pre></div>
<p>Au lieu de se contenter d’un <code class="sourceCode haskell"><span class="dt">Maybe</span></code>, nous allons utiliser le type <code class="sourceCode haskell"><span class="dt">Either</span></code> un peu plus riche&nbsp;: comme vous pouvez le voir dans la documentation de <code class="sourceCode haskell"><span class="dt">Data.Either</span></code>, ce type est défini ainsi&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Either</span> a b <span class="fu">=</span> <span class="dt">Left</span> a
                <span class="fu">|</span> <span class="dt">Right</span> b</code></pre></div>
<p>Ce type est souvent utilisé comme un <code class="sourceCode haskell"><span class="dt">Maybe</span></code> enrichi, de sorte à avoir une explication de l’erreur en cas d’échec. <code class="sourceCode haskell"><span class="dt">Right</span></code> est alors utilisé pour le cas de réussite (<em>right</em> signifie à la fois <em>droit</em> et <em>correct</em>), <code class="sourceCode haskell"><span class="dt">Left</span></code> le cas d’erreur.</p>
<p>Nous utiliserons donc les types suivants&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ValeurB</span> <span class="fu">=</span> <span class="dt">VLitteralB</span> <span class="dt">Litteral</span>
             <span class="fu">|</span> <span class="dt">VFonctionB</span> (<span class="dt">ValeurB</span> <span class="ot">-&gt;</span> <span class="dt">ErrValB</span>)

<span class="kw">type</span> <span class="dt">MsgErreur</span> <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">ErrValB</span>   <span class="fu">=</span> <span class="dt">Either</span> <span class="dt">MsgErreur</span> <span class="dt">ValeurB</span></code></pre></div>
<ol start="21" type="1">
<li>Définissez une instance de la classe <code class="sourceCode haskell"><span class="dt">Show</span></code> pour votre type <code class="sourceCode haskell"><span class="dt">ValeurB</span></code>.</li>
</ol>
<p>Les causes possibles d’erreurs sont donc&nbsp;:</p>
<ul>
<li>une variable à interpréter qui n’est pas définie dans l’environnement,</li>
<li>une application d’un littéral à quelque chose,</li>
<li>la propagation d’une erreur (erreur appliquée à une valeur, ou fonction appliquée à une erreur).</li>
</ul>
<ol start="22" type="1">
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">interpreteB ::</span> <span class="dt">Environnement</span> <span class="dt">ValeurB</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">ErrValB</span></code>.</p>
<p>Par exemple&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"1"</span>)
<span class="dt">Right</span> <span class="dv">1</span>
ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"λx -&gt; x"</span>)
<span class="dt">Right</span> λ
ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"(λx -&gt; x) 1"</span>)
<span class="dt">Right</span> <span class="dv">1</span>

ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"λx -&gt; y"</span>)
<span class="dt">Right</span> λ
ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"(λx -&gt; y) 1"</span>)
<span class="dt">Left</span> <span class="st">"la variable y n'est pas definie"</span>

ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"x"</span>)
<span class="dt">Left</span> <span class="st">"la variable x n'est pas definie"</span>
ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"1 2"</span>)
<span class="dt">Left</span> <span class="st">"1 n'est pas une fonction, application impossible"</span>
ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"1 2 x"</span>)
<span class="dt">Left</span> <span class="st">"1 n'est pas une fonction, application impossible"</span>
ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"x 1 2 x"</span>)
<span class="dt">Left</span> <span class="st">"la variable x n'est pas definie"</span>
ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"x 1 2"</span>)
<span class="dt">Left</span> <span class="st">"la variable x n'est pas definie"</span>
ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"(λx -&gt; x) x"</span>)
<span class="dt">Left</span> <span class="st">"la variable x n'est pas definie"</span>
ghci<span class="fu">&gt;</span> interpreteB [] (ras <span class="st">"(λx -&gt; x) y"</span>)
<span class="dt">Left</span> <span class="st">"la variable y n'est pas definie"</span></code></pre></div></li>
</ol>
<p>Désormais les primitives peuvent aussi générer des erreurs.</p>
<ol start="23" type="1">
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">addB ::</span> <span class="dt">ValeurB</span></code> qui retourne une erreur si un de ses deux arguments n’est pas un entier. Elle propagera aussi les erreurs éventuelles de ses arguments.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteB [(<span class="st">"add"</span>,addB)] (ras <span class="st">"add 1 2"</span>)
<span class="dt">Right</span> <span class="dv">3</span>
ghci<span class="fu">&gt;</span> interpreteB [(<span class="st">"add"</span>,addB)] (ras <span class="st">"add 1 True"</span>)
<span class="dt">Left</span> <span class="st">"True n'est pas un entier"</span>
ghci<span class="fu">&gt;</span> interpreteB [(<span class="st">"add"</span>,addB)] (ras <span class="st">"add (λx -&gt; x) y"</span>)
<span class="dt">Left</span> <span class="st">"\955 n'est pas un entier"</span>
ghci<span class="fu">&gt;</span> interpreteB [(<span class="st">"add"</span>,addB)] (ras <span class="st">"add 1 y"</span>)
<span class="dt">Left</span> <span class="st">"la variable y n'est pas definie"</span>
ghci<span class="fu">&gt;</span> interpreteB [(<span class="st">"add"</span>,addB)] (ras <span class="st">"add 1 ((λx -&gt; x) y)"</span>)
<span class="dt">Left</span> <span class="st">"la variable y n'est pas definie"</span>
ghci<span class="fu">&gt;</span> interpreteB [(<span class="st">"add"</span>,addB)] (ras <span class="st">"add 1 (2 y)"</span>)
<span class="dt">Left</span> <span class="st">"2 n'est pas une fonction, application impossible"</span></code></pre></div></li>
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">quotB ::</span> <span class="dt">ValeurB</span></code> qui, en plus de détecter toutes les erreurs que détecte <code class="sourceCode haskell">addB</code>, détecte aussi la division par zéro.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteB [(<span class="st">"quot"</span>,quotB)] (ras <span class="st">"quot 13 4"</span>)
<span class="dt">Right</span> <span class="dv">3</span>
ghci<span class="fu">&gt;</span> interpreteB [(<span class="st">"quot"</span>,quotB)] (ras <span class="st">"quot 13 0"</span>)
<span class="dt">Left</span> <span class="st">"division par zero"</span></code></pre></div></li>
</ol>
<h3 id="interprète-traçant">Interprète traçant</h3>
<p>Repartons du code de l’interprète simple, pour lui ajouter la possibilité de tracer l’avancée du calcul. Pour cela, nous allons produire, comme résultat, non seulement la valeur proprement dite, mais également une chaîne de caractères.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ValeurC</span> <span class="fu">=</span> <span class="dt">VLitteralC</span> <span class="dt">Litteral</span>
             <span class="fu">|</span> <span class="dt">VFonctionC</span> (<span class="dt">ValeurC</span> <span class="ot">-&gt;</span> <span class="dt">OutValC</span>)

<span class="kw">type</span> <span class="dt">Trace</span>   <span class="fu">=</span> <span class="dt">String</span>
<span class="kw">type</span> <span class="dt">OutValC</span> <span class="fu">=</span> (<span class="dt">Trace</span>, <span class="dt">ValeurC</span>)</code></pre></div>
<ol start="25" type="1">
<li>Définissez l’instance de <code class="sourceCode haskell"><span class="dt">Show</span></code> pour <code class="sourceCode haskell"><span class="dt">ValeurC</span></code>.</li>
</ol>
<p>L’interprète aura désormais le type <code class="sourceCode haskell"><span class="dt">Environnement</span> <span class="dt">ValeurC</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">OutValC</span></code>. Pour indiquer l’avancée du calcul, nous allons simplement ajouter un <code class="sourceCode haskell"><span class="ch">'.'</span></code> à la trace à chaque fois que nous interprétons une application, de sorte que la trace d’une application sera la concaténation de&nbsp;:</p>
<ul>
<li>la trace de l’interprétation de la fonction,</li>
<li>la trace de l’interprétation de l’argument,</li>
<li>un point point pour l’application elle-même,</li>
<li>la trace de la suite du calcul.</li>
</ul>
<ol start="26" type="1">
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">interpreteC ::</span> <span class="dt">Environnement</span> <span class="dt">ValeurC</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">OutValC</span></code> tel que&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteC [] (ras <span class="st">"1"</span>)
(<span class="st">""</span>,<span class="dv">1</span>)
ghci<span class="fu">&gt;</span> interpreteC [] (ras <span class="st">"(λx -&gt; x) 1"</span>)
(<span class="st">"."</span>,<span class="dv">1</span>)
ghci<span class="fu">&gt;</span> interpreteC [] (ras <span class="st">"(λx -&gt; λy -&gt; x) 1 2"</span>)
(<span class="st">".."</span>,<span class="dv">1</span>)
ghci<span class="fu">&gt;</span> interpreteC [] (ras <span class="st">"(λx -&gt; x x)(λx -&gt; x x)"</span>)
(<span class="st">"............................................^C..Interrupted.</span></code></pre></div></li>
</ol>
<p>Notez que cet interprète interagit de façon subtile avec l’évaluation paresseuse. Si nous avions défini&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">OutValC</span> <span class="fu">=</span> (<span class="dt">ValeurC</span>, <span class="dt">Trace</span>)</code></pre></div>
<p>l’évaluation dans GHCi de (λx → x x)(λx → x x) n’aurait affiché qu’une parenthèse ouvrante avant de boucler.</p>
<p>Plus généralement, pour afficher la trace, GHCi cherche à obtenir chacun de ses caractères, ce qui veut dire que la façon dont vous la construisez change l’ordre d’évaluation…</p>
<p>Pour finir sur cet interprète, nous allons définir une primitive <code class="sourceCode haskell">pingC</code> qui correspondra simplement à la fonction identité mais affichant un <code class="sourceCode haskell"><span class="ch">'p'</span></code> dans la trace.</p>
<ol start="27" type="1">
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">pingC ::</span> <span class="dt">ValeurC</span></code>.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteC [(<span class="st">"ping"</span>,pingC)] (ras <span class="st">"ping 12"</span>)
(<span class="st">".p"</span>,<span class="dv">12</span>)
ghci<span class="fu">&gt;</span> interpreteC [(<span class="st">"ping"</span>,pingC)] (ras <span class="st">"ping ping"</span>)
(<span class="st">".p"</span>,λ)
ghci<span class="fu">&gt;</span> interpreteC [(<span class="st">"ping"</span>,pingC)] (ras <span class="st">"ping ping 12"</span>)
(<span class="st">".p.p"</span>,<span class="dv">12</span>)
ghci<span class="fu">&gt;</span> interpreteC [(<span class="st">"ping"</span>,pingC)] (ras <span class="st">"(λx -&gt; x x) ping 12"</span>)
(<span class="st">"..p.p"</span>,<span class="dv">12</span>)</code></pre></div></li>
</ol>
<h3 id="interprète-monadique">Interprète monadique</h3>
<p>Ces variations sur l’interprète amène à un triste constat&nbsp;: chaque variante a demandé de récrire une grande partie du code, même pour les cas qui ne sont pas concernés. Par exemple, bien qu’ils ne produisent pas de trace, le cas des littéraux est différent entre <code class="sourceCode haskell">interpreteA</code> et <code class="sourceCode haskell">interpreteC</code> parce qu’à chaque fois, l’interprète est fortement lié au type de la valeur à retourner. Nous nous proposons ici de généraliser l’interprète pour qu’il soit plus adaptable.</p>
<p>Quel type donner à la fonction d’interprétation généralisée&nbsp;? En partant des exemples précédents, nous pouvons constater qu’ils sont toujours de la forme suivante&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpreteM ::</span> <span class="dt">Environnement</span> <span class="dt">ValeurM</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="fu">?</span> <span class="dt">ValeurM</span></code></pre></div>
<p>avec comme type du résultat un type qui est construit sur le type des valeurs&nbsp;: c’était directement une valeur pour l’interprète le plus simple, un type un peu plus riche dans les deux autres cas. Nous voudrions donc quelque chose comme&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ValeurM</span> <span class="fu">=</span> <span class="dt">VLitteralM</span> <span class="dt">Litteral</span>
             <span class="fu">|</span> <span class="dt">VFonctionM</span> (<span class="dt">ValeurM</span> <span class="ot">-&gt;</span> m <span class="dt">ValeurM</span>)

<span class="ot">interpreteM ::</span> <span class="dt">Environnement</span> <span class="dt">ValeurM</span> <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> m <span class="dt">ValeurM</span></code></pre></div>
<p>Haskell refuse cette définition de <code class="sourceCode haskell"><span class="dt">ValeurM</span></code>&nbsp;: <code class="sourceCode haskell">m</code> n’est pas lié. Nous devons donc utiliser cette définition&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ValeurM</span> m <span class="fu">=</span> <span class="dt">VLitteralM</span> <span class="dt">Litteral</span>
               <span class="fu">|</span> <span class="dt">VFonctionM</span> (<span class="dt">ValeurM</span> m <span class="ot">-&gt;</span> m (<span class="dt">ValeurM</span> m))</code></pre></div>
<ol start="28" type="1">
<li>Définissez l’instance de <code class="sourceCode haskell"><span class="dt">Show</span></code> pour <code class="sourceCode haskell"><span class="dt">ValeurM</span> m</code> (puisque <code class="sourceCode haskell"><span class="dt">ValeurM</span></code> attend un argument pour être un type, il faut lui en donner un pour définir une instance de <code class="sourceCode haskell"><span class="dt">Show</span></code>)<a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fn4" class="footnoteRef" id="fnref4"><sup>4</sup></a>.</li>
</ol>
<h4 id="variante-simple">Variante simple</h4>
<p>Pour adapter l’interprète simple à cette définition, il faut définir un type <code class="sourceCode haskell"><span class="dt">SimpleM</span></code> pour instancier le&nbsp;<code class="sourceCode haskell">m</code> de la définition.</p>
<p>Nous prendrons le type le plus simple pour notre objectif&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">SimpleM</span> v <span class="fu">=</span> <span class="dt">S</span> v
               <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<ol start="29" type="1">
<li><p>Transformez votre <code class="sourceCode haskell">interpreteA</code> en un</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpreteSimpleM ::</span> <span class="dt">Environnement</span> (<span class="dt">ValeurM</span> <span class="dt">SimpleM</span>) <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> <span class="dt">SimpleM</span> (<span class="dt">ValeurM</span> <span class="dt">SimpleM</span>)</code></pre></div>
<p>en ajoutant et enlevant le constructeur <code class="sourceCode haskell"><span class="dt">S</span></code> aux endroits opportuns.</p></li>
</ol>
<p>Tous les endroits où vous avez dû ajouter et enlever des <code class="sourceCode haskell"><span class="dt">S</span></code> sont des points du code qui vont devoir changer quand vous allez remplacer <code class="sourceCode haskell"><span class="dt">SimpleM</span></code> par un autre type pour les variantes de l’interprète. Les classes de types permettent justement de faire de la surcharge de fonctions qui sont instanciées selon les types.</p>
<p>Ces différents types vont être des <em>monades</em>. Les deux fonctions essentielles d’une monade sont&nbsp;:</p>
<ul>
<li><code class="sourceCode haskell">return<span class="ot"> ::</span> a <span class="ot">-&gt;</span> m a</code>,</li>
<li><code class="sourceCode haskell"><span class="ot">(&gt;&gt;=) ::</span> m a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> m b) <span class="ot">-&gt;</span> m b</code>.</li>
</ul>
<p>Définissons la monade associée à <code class="sourceCode haskell"><span class="dt">SimpleM</span></code>&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">SimpleM</span> <span class="kw">where</span>
    return      <span class="fu">=</span> <span class="dt">S</span>
    (<span class="dt">S</span> v) <span class="fu">&gt;&gt;=</span> f <span class="fu">=</span> f v</code></pre></div>
<p>Attention&nbsp;: en salle TP, vous utilisez GHC 7.6. Si vous écrivez votre code avec une version plus récente de GHC, consultez cette note<a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fn5" class="footnoteRef" id="fnref5"><sup>5</sup></a>.</p>
<ol start="30" type="1">
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">interpreteM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Environnement</span> (<span class="dt">ValeurM</span> m) <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> m (<span class="dt">ValeurM</span> m)</code>.</p>
<p><code class="sourceCode haskell">interpreteM</code> ressemblera beaucoup à <code class="sourceCode haskell">interpreteSimpleM</code>, où les ajouts de <code class="sourceCode haskell"><span class="dt">S</span></code> sont des appels à <code class="sourceCode haskell">return</code>, et où les enlèvements de&nbsp;<code class="sourceCode haskell"><span class="dt">S</span></code> correspondent à des enchaînements utilisant <code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> ou la notation <code class="sourceCode haskell"><span class="kw">do</span></code> (<code class="sourceCode haskell"><span class="fu">&gt;&gt;=</span></code> et/ou <code class="sourceCode haskell"><span class="kw">do</span></code> ne devraient être utiles que pour l’application).</p></li>
</ol>
<p>Nous pouvons alors définir un interprète en instanciant la monade&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">InterpreteM</span> m <span class="fu">=</span> <span class="dt">Environnement</span> (<span class="dt">ValeurM</span> m) <span class="ot">-&gt;</span> <span class="dt">Expression</span> <span class="ot">-&gt;</span> m (<span class="dt">ValeurM</span> m)

<span class="ot">interpreteS ::</span> <span class="dt">InterpreteM</span> <span class="dt">SimpleM</span>
interpreteS <span class="fu">=</span> interpreteM</code></pre></div>
<ol start="31" type="1">
<li>Testez votre interprète <code class="sourceCode haskell">interpreteS</code> pour vérifier qu’il se comporte comme <code class="sourceCode haskell">interpreteSimpleM</code>.</li>
</ol>
<h4 id="variante-traçante">Variante traçante</h4>
<p>Mettons maintenant à l’épreuve la malléabilité de cet interprète.</p>
<p>Définissons tout d’abord une variante traçante.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">TraceM</span> v <span class="fu">=</span> <span class="dt">T</span> (<span class="dt">Trace</span>, v)
              <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<ol start="32" type="1">
<li>Définissez l’instance de <code class="sourceCode haskell"><span class="dt">Monad</span></code> pour <code class="sourceCode haskell"><span class="dt">TraceM</span></code>&nbsp;:
<ul>
<li><code class="sourceCode haskell">return</code> ne génère qu’une trace vide,</li>
<li><code class="sourceCode haskell"><span class="dt">T</span> (t, v) <span class="fu">&gt;&gt;=</span> f</code> doit déclencher <code class="sourceCode haskell">f</code> avec la valeur&nbsp;<code class="sourceCode haskell">v</code> (qui sera de type <code class="sourceCode haskell"><span class="dt">ValeurM</span></code> dans nos applications) et créer une nouvelle valeur de type&nbsp;<code class="sourceCode haskell"><span class="dt">TraceM</span> v</code> en concaténant la trace&nbsp;<code class="sourceCode haskell">t</code> et celle produite par&nbsp;<code class="sourceCode haskell">f</code>.</li>
</ul></li>
</ol>
<p>En définissant&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">interpreteMT ::</span> <span class="dt">InterpreteM</span> <span class="dt">TraceM</span>
interpreteMT <span class="fu">=</span> interpreteM

<span class="ot">pingM ::</span> <span class="dt">ValeurM</span> <span class="dt">TraceM</span>
pingM <span class="fu">=</span> <span class="dt">VFonctionM</span> (\v <span class="ot">-&gt;</span> <span class="dt">T</span> (<span class="st">"p"</span>, v))</code></pre></div>
<p>nous avons directement&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> interpreteMT [(<span class="st">"ping"</span>, pingM)] (ras <span class="st">"ping 12"</span>)
<span class="dt">T</span> (<span class="st">"p"</span>,<span class="dv">12</span>)
ghci<span class="fu">&gt;</span> interpreteMT [(<span class="st">"ping"</span>, pingM)] (ras <span class="st">"ping 12"</span>)
<span class="dt">T</span> (<span class="st">"p"</span>,<span class="dv">12</span>)
ghci<span class="fu">&gt;</span> interpreteMT [(<span class="st">"ping"</span>, pingM)] (ras <span class="st">"ping ping"</span>)
<span class="dt">T</span> (<span class="st">"p"</span>,λ)
ghci<span class="fu">&gt;</span> interpreteMT [(<span class="st">"ping"</span>, pingM)] (ras <span class="st">"ping ping 12"</span>)
<span class="dt">T</span> (<span class="st">"pp"</span>,<span class="dv">12</span>)
ghci<span class="fu">&gt;</span> interpreteMT [(<span class="st">"ping"</span>, pingM)] (ras <span class="st">"(λx -&gt; x ) ping 12"</span>)
<span class="dt">T</span> (<span class="st">"p"</span>,<span class="dv">12</span>)
ghci<span class="fu">&gt;</span> interpreteMT [(<span class="st">"ping"</span>, pingM)] (ras <span class="st">"(λx -&gt; x x) ping 12"</span>)
<span class="dt">T</span> (<span class="st">"pp"</span>,<span class="dv">12</span>)</code></pre></div>
<p>sans avoir modifié une seule ligne de l’interprète&nbsp;!</p>
<p>Bien entendu, si nous voulons tracer les applications, comme nous l’avions fait dans <code class="sourceCode haskell">interpreteC</code>, il faut modifier son code. Cependant, il suffira cette fois d’un petit ajout dans le seul cas qui change, l’application.</p>
<ol start="33" type="1">
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">interpreteMT' ::</span> <span class="dt">InterpreteM</span> <span class="dt">TraceM</span></code> pour retrouver exactement les mêmes traces que <code class="sourceCode haskell">interpreteC</code>.</p>
<p>Notez au passage que <code class="sourceCode haskell">pingM</code> n’a pas à être modifié&nbsp;!</p></li>
</ol>
<h4 id="variante-avec-erreurs">Variante avec erreurs</h4>
<p>Enfin, définissons une variante avec erreurs.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">ErreurM</span> v <span class="fu">=</span> <span class="dt">Succes</span> v
               <span class="fu">|</span> <span class="dt">Erreur</span> <span class="dt">String</span>
               <span class="kw">deriving</span> <span class="dt">Show</span></code></pre></div>
<p>Les monades contiennent une fonction dont la définition est optionnelle mais bien utile dans notre cas&nbsp;: <code class="sourceCode haskell">fail<span class="ot"> ::</span> <span class="dt">String</span> <span class="ot">-&gt;</span> m a</code>. Par défaut elle lève une exception mais ici nous allons la redéfinir&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> <span class="dt">ErreurM</span> <span class="kw">where</span>
    fail e <span class="fu">=</span> <span class="dt">Erreur</span> e
    …</code></pre></div>
<ol start="34" type="1">
<li><p>Complétez la définition de l’instance de <code class="sourceCode haskell"><span class="dt">Monad</span> <span class="dt">ErreurM</span></code>.</p></li>
<li><p>Définissez <code class="sourceCode haskell"><span class="ot">interpreteE ::</span> <span class="dt">InterpreteM</span> <span class="dt">ErreurM</span></code>.</p>
<p>En utilisant <code class="sourceCode haskell">fail</code> au lieu d’utiliser explicitement <code class="sourceCode haskell"><span class="dt">Erreur</span></code>, vous pouvez même définir un interprète de type <code class="sourceCode haskell"><span class="ot">interpreteE ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">InterpreteM</span> m</code>, qui sera tout aussi valable dans les monades <code class="sourceCode haskell"><span class="dt">SimpleM</span></code> et <code class="sourceCode haskell"><span class="dt">TraceM</span></code> précédentes (mais où les erreurs lèveront des exceptions, bien entendu)&nbsp;!</p>
<p>Vérifiez que vous obtenez les mêmes comportements qu’avec <code class="sourceCode haskell">interpreteB</code>.</p></li>
</ol>
<h4 id="cerise-sur-le-gâteau">Cerise sur le gâteau</h4>
<p>Il est un peu fastidieux d’injecter les fonctions de Haskell telles que <code class="sourceCode haskell">(<span class="fu">+</span>)</code> en primitives du langage. D’autant que le travail s’avère être le même pour toutes les fonctions.</p>
<p>Pour éviter de se répéter à l’infini, nous pouvons utiliser les classes de types pour définir une fonction surchargée <code class="sourceCode haskell">injecte</code> qui transforme une valeur (une fonction, par exemple) Haskell en une <code class="sourceCode haskell"><span class="dt">ValeurM</span></code>.</p>
<p>Nous allons pour cela utiliser des extensions du langage Haskell, que vous activerez par ces <em>pragmas</em> en début de votre fichier source&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE FlexibleInstances     #-}</span>
<span class="ot">{-# LANGUAGE MultiParamTypeClasses #-}</span></code></pre></div>
<p>Définissons la classe des valeurs Haskell injectables dans notre langage&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Injectable</span> m t <span class="kw">where</span>
<span class="ot">    injecte ::</span> t <span class="ot">-&gt;</span> <span class="dt">ValeurM</span> m</code></pre></div>
<p>Pour chaque valeur de type <code class="sourceCode haskell">t</code> que nous voulons convertir en <code class="sourceCode haskell"><span class="dt">ValeurM</span></code>, nous allons donc définir une instance de cette classe de types. Par exemple, pour les booléens, nous aurons&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Injectable</span> m <span class="dt">Bool</span> <span class="kw">where</span>
    injecte <span class="fu">=</span> <span class="dt">VLitteralM</span> <span class="fu">.</span> <span class="dt">Bool</span></code></pre></div>
<ol start="36" type="1">
<li>Définissez l’instance de <code class="sourceCode haskell"><span class="dt">Injectable</span></code> pour les <code class="sourceCode haskell"><span class="dt">Integer</span></code>.</li>
</ol>
<p>Nous voulons pouvoir injecter automatiquement une fonction comme <code class="sourceCode haskell">negate<span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span></code>. Il nous faut pour cela une instance pour un type fonctionnel. Ainsi, si nous avons à injecter une fonction de type <code class="sourceCode haskell"><span class="dt">Integer</span> <span class="ot">-&gt;</span> t</code>, nous pouvons utiliser une <code class="sourceCode haskell"><span class="dt">VFonctionM</span></code> qui va attendre un entier. Pour produire son résultat (qui doit correspondre au type&nbsp;<code class="sourceCode haskell">t</code>), elle utilisera bien entendu l’injection du résultat.</p>
<ol start="37" type="1">
<li><p>Définissez les instances de <code class="sourceCode haskell"><span class="dt">Injectable</span></code> pour les fonctions prenant en premier argument un <code class="sourceCode haskell"><span class="dt">Integer</span></code> ou un <code class="sourceCode haskell"><span class="dt">Bool</span></code>&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> (<span class="dt">Monad</span> m, <span class="dt">Injectable</span> m t) <span class="ot">=&gt;</span> <span class="dt">Injectable</span> m (<span class="dt">Bool</span> <span class="ot">-&gt;</span> t) <span class="kw">where</span>
    injecte f <span class="fu">=</span> …

<span class="kw">instance</span> (<span class="dt">Monad</span> m, <span class="dt">Injectable</span> m t) <span class="ot">=&gt;</span> <span class="dt">Injectable</span> m (<span class="dt">Integer</span> <span class="ot">-&gt;</span> t) <span class="kw">where</span>
    injecte f <span class="fu">=</span> …</code></pre></div></li>
<li><p>En définissant un environnement</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">envM ::</span> <span class="dt">Monad</span> m <span class="ot">=&gt;</span> <span class="dt">Environnement</span> (<span class="dt">ValeurM</span> m)
envM <span class="fu">=</span> [ (<span class="st">"add"</span>,   injecte (<span class="ot">(+) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>))
       , (<span class="st">"soust"</span>, injecte (<span class="ot">(-) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>))
       , (<span class="st">"mult"</span>,  injecte (<span class="ot">(*) ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>))
       , (<span class="st">"quot"</span>,  injecte (quot<span class="ot"> ::</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span> <span class="ot">-&gt;</span> <span class="dt">Integer</span>))
       , (<span class="st">"et"</span>,    injecte (<span class="fu">&amp;&amp;</span>))
       , (<span class="st">"ou"</span>,    injecte (<span class="fu">||</span>))
       , (<span class="st">"non"</span>,   injecte not) ]</code></pre></div>
<p>etc., définissez un interprète monadique avec toutes les primitives qui vous intéressent et faites-en une version interactive.</p></li>
</ol>
<hr>
<p>Références ayant inspiré cet énoncé&nbsp;:</p>
<ul>
<li>Philip Wadler, <em>The essence of functional programming</em>,</li>
<li>Philip Wadler, <em>Monads for functional programming</em>.</li>
</ul>
<section class="footnotes">
<hr>
<ol>
<li id="fn1"><p>Vous pouvez aller voir le module <code class="sourceCode haskell"><span class="dt">CoreSyn</span></code> dans l’API de GHC&nbsp;!<a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fnref1">↩</a></p></li>
<li id="fn2"><p>Nous avons vu en cours qu’il est possible d’encoder les littéraux par des fonctions mais il est plus simple et plus efficace de les ajouter directement.<a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fnref2">↩</a></p></li>
<li id="fn3"><p>Notez que cette recombinaison correspond au fait que les fonctions sont curryfiées&nbsp;: on applique une fonction à deux arguments à son premier argument, ce qui nous donne une fonction&nbsp;; puis on applique cette fonction résultat au second argument.<a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fnref3">↩</a></p></li>
<li id="fn4"><p>Haskell utilise des <em>sortes</em>, un système de types pour les types. Vous pouvez ainsi demander&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="dt">ValeurA</span>
<span class="dt">ValeurA</span><span class="ot"> ::</span> <span class="fu">*</span>
ghci<span class="fu">&gt;</span> <span class="fu">:</span>kind <span class="dt">ValeurM</span>
<span class="dt">ValeurM</span><span class="ot"> ::</span> (<span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>) <span class="ot">-&gt;</span> <span class="fu">*</span></code></pre></div>
<p>où <code class="sourceCode haskell"><span class="fu">*</span></code> est la <em>sorte</em> d’un type. Vous pouvez ainsi explorer comment il sorte les classes de types telle que <code class="sourceCode haskell"><span class="dt">Show</span></code>…<a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fnref4">↩</a></p></li>
<li id="fn5"><p>À partir de GHC 7.10, la classe <code class="sourceCode haskell"><span class="dt">Monad</span></code> est une classe fille de <code class="sourceCode haskell"><span class="dt">Applicative</span></code>, qui est elle-même fille de <code class="sourceCode haskell"><span class="dt">Functor</span></code>. Du coup, toute instance de <code class="sourceCode haskell"><span class="dt">Monad</span></code> devra être aussi instance des deux autres classes. Il suffit pour cela d’ajouter, pour chacune de vos instances de <code class="sourceCode haskell"><span class="dt">Monad</span></code>, par exemple <code class="sourceCode haskell"><span class="dt">SimpleM</span></code>&nbsp;:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">instance</span> <span class="dt">Applicative</span> <span class="dt">SimpleM</span> <span class="kw">where</span>
    pure  <span class="fu">=</span> return
    (<span class="fu">&lt;*&gt;</span>) <span class="fu">=</span> ap

<span class="kw">instance</span> <span class="dt">Functor</span> <span class="dt">SimpleM</span> <span class="kw">where</span>
    fmap  <span class="fu">=</span> liftM</code></pre></div>
<p>où <code class="sourceCode haskell">ap</code> et <code class="sourceCode haskell">liftM</code> sont des fonctions du module <code class="sourceCode haskell"><span class="dt">Control.Monad</span></code>.<a href="http://www.fil.univ-lille1.fr/~hym/e/pf/tdtp/tp-interprete.html#fnref5">↩</a></p></li>
</ol>
</section>
</div>
<footer></footer>

</body></html>